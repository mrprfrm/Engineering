---
tags:
 - translation
 - SQL
---

**Оригинал**
[Статья Joe Celko](https://www.ibase.ru/files/articles/programming/dbmstrees/sqltrees.html)

Это давний вопрос, что актуален по сей день. Я встречал огромное количество вопросов по теме деревьев и иерархии в SQL в обсуждениях и новостных группах. Вот типичный пример древовидной структуры в книгах по SQL, что носит название `модель списка смежности` и выглядит следующим образом:

```SQL
CREATE TABLE Personnel
	(emp CHAR(10) NOT NULL PRIMARY KEY,
	boss CHAR(10) DEFAULT NULL REFERENCES Personnel(emp),
	salary DECIMAL(6,2) NOT NULL DEFAULT 100.00);
```

| emp | boss | salary |
| --- | --- | --- |
| Albert | NULL | 1000 |
| Bert | Albert | 900 |
| Chuck | Albert | 900 |
| Donna | Chuck | 800 |
| Eddie | Chuck | 700 |
| Fried | Chuck | 600 |

Таблица 1: Модель списка смежности

Решение, где мы определяем столбцы для хранения `boss` и `employee`, часто встречается в учебниках. Таблица 1 (без столбцов `lft` и `rgt`) — называется `моделью списка смежности` в честь одноименного метода теории графов, когда пары узлов графа являются смежными друг другу.

Ещё один способ представления деревьев — это показать их в виде `вложенных множеств`.  Поскольку SQL является языком, ориентированным на множества, такая модель выглядит удачнее, чем стандартное представление деревьев в виде `списка смежности`, который вы скорее всего встретите в большинстве учебников. 

```SQL
CREATE TABLE Personnel
	(emp CHAR(10) NOT NULL PRIMARY KEY,
	lft INTEGER NOT NULL UNIQUE CHECK (lft > 0),
	rgt INTEGER NOT NULL UNIQUE CHECK (rgt > 1),
	CONSTRAINT order_okay CHECK (lft < rgt) );
```

| Personnel emp | lft | rgt |
| --- | --- | --- |
| Albert | 1 | 12 |
| Bert | 2 | 3 |
| Chuck | 4 | 11 |
| Donna | 5 | 6 |
| Eddie | 7 | 8 |
| Fred | 9 | 10 |

Таблица 2: Модель вложенных множеств

> TODO Добавить рисунок соответствующего графа

Данные в `таблице 1` денормальзованны, утверждать подобное можно сразу по ряду причин. По меньшей мере, в `таблице 1` перемешаны информация о персонале, и представление иерархии организации. Но давайте абстрагируемся и предположим, что имена персонала, в данном случае — это названия должностей, а также предположим 
что у нас есть отдельная, связанная таблица, где мы храним информацию о персонале, что занимает эти должности.