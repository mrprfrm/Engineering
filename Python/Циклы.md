---
aliases:
  - Loops
authors:
  - Anton Petrov
status: Draft
tags:
  - python
  - loops
  - for
  - while
---
## Цикл while

Подсчёт элементов последовательности Фибоначчи происходит в цикле. В данном случае мы используем цикл `while` — цикл с условием. Код в теле такого цикла будет выполняться до тех пор, пока условие цикла остаётся истинным, в данном случае, до тех пор, пока `a < 10`.

В Python в качестве условия может выступать не только логическое выражение, но и любая последовательность или даже число. Внутри условий Python каждое переданное значение будет приведено к типу данных `bool`. Согласно логике такого преобразования, истинной (`True`) будет являться любое значение, отличное от нуля, а также любая последовательность ненулевой длины. Ложью (`False`) будет являться любое другое значение.

Тело цикла в Python — это любая, сколько угодно комплексная логика, помещённая после объявления цикла с отступом в четыре пробела. В Python для определения вложенного блока кода используются отступы, в отличие от большинства других языков, использующих фигурные скобки (`{`).

Блоки кода позволяют определить область видимости для созданных в этих блоках переменных и функций. Также они не ограничены по степени вложенности, то есть каждый из блоков может также содержать вложенные блоки.

## Цикл for

Цикл `for` в Python предназначен исключительно для работы с итераторами. В нём последовательно перебираются элементы итератора, вплоть до момента, когда в нём не останется необработанных элементов, тогда цикл завершает свою работу и возвращает управление в основной поток программы.

Такой подход отличается от реализации циклов в некоторых других языках, описывающих арифметическую прогрессию (как в Pascal) или определяющих шаг итерации и условие выхода из цикла (как в C). 

```python
>>> # Измерим длинну нескольких строк:
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print(w, len(w))
...
cat 3
window 6
defenestrate 12
```

> В Python также доступен цикл `while`. Он реализует принципиально отличный поход — код внутри цикла `while` будет выполняться до тех пока, пока выражение в определении цикла будет истинно.

> TODO: как нибудь подвести к задаче модификации, а то как то с какой стати мы вообще эту задачу разбираем

Теперь рассмотрим решение по модификации исходной последовательности в цикле. В данном случае мы обходим словарь — последовательность пар ключ-значение фиксированной длинны и любое изменение длинны словаря во время его обхода приведёт к ошибке: `RuntimeError: dictionary changed size during iteration`. Поэтому для данного решения мы используем копию словаря.

```python
# Создадим простой словарь
users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}

# Обойдём копию исходного словаря и удалим некоторые из элементов в исходном словаре
for user, status in users.copy().items():
    if status == 'inactive':
        del users[user]

# Создадим новый словарь активных пользователей
active_users = {}
for user, status in users.items():
    if status == 'active':
        active_users[user] = status
```

## Функция range

В случае, когда задача сводится к перебору чисел, например индексов в заданном диапазоне, мы можем использовать лаконичный синтаксис цикла `for` в комбинации с функцией `range()`.

Функция `range()` возвращает арифметическую последовательность чисел:

```python
>>> for i in range(5):
...     print(i)
...
0
1
2
3
4
```

`range(1, 5) + range(5, 10) = range(1, 10)`

Данная конечная точка никогда не является частью сгенерированной последовательности; range(10) генерирует 10 значений, допустимые индексы для элементов последовательности длиной 10. Можно позволить диапазону начинаться с другого числа или указать другое приращение (даже отрицательное; иногда это называется «шагом»). ):

```python
>>> list(range(5, 10))
[5, 6, 7, 8, 9]

>>> list(range(0, 10, 3))
[0, 3, 6, 9]

>>> list(range(-10, -100, -30))
[-10, -40, -70]
```

> В данном случае мы приводим результат функции `range()` ко списку, поскольку она возвращает итератор вместо списка, что будет расчитываться в процессе обхода через цикл.

Чтобы перебирать индексы последовательности, вы можете объединить `range()` и `len()` следующим образом:

```python
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
```

> В большинстве случаев в место `range()` уместнее использовать функцию `enumerate()`, что принимает на вход любой итератор в возвращает последовательность пар индекс-значение.

Во многих отношениях объект, возвращаемый функцией range(), ведет себя так, как будто это список, но на самом деле это не так. Это объект, который возвращает последовательные элементы желаемой последовательности, когда вы перебираете его, но на самом деле он не составляет список, тем самым экономя место.

Мы говорим, что такой объект является итеративным, то есть подходит в качестве цели для функций и конструкций, которые ожидают чего-то, из чего они могут получать последовательные элементы, пока запас не будет исчерпан. Мы видели, что такой конструкцией является оператор for, а примером функции, принимающей итерируемый объект, является sum():

```python
sum(range(4))  # 0 + 1 + 2 + 3
6
```

Позже мы увидим больше функций, которые возвращают итерации и принимают итерации в качестве аргументов. В главе «Структуры данных» мы более подробно обсудим list().
## Оператор break

Оператор Break выходит из самого внутреннего цикла for или while.

Цикл for или while может включать в себя предложение else.

В цикле for предложение else выполняется после того, как цикл достигает последней итерации.

В цикле while он выполняется после того, как условие цикла становится ложным.

В любом типе цикла предложение else не выполняется, если цикл был завершен прерыванием.

Это иллюстрируется следующим циклом for, который ищет простые числа:

```python
>>> for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print(n, 'equals', x, '*', n//x)
...             break
...     else:
...         # loop fell through without finding a factor
...         print(n, 'is a prime number')
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
```

(Да, это правильный код. Посмотрите внимательно: предложение else принадлежит циклу for, а не оператору if.)

При использовании с циклом предложение else имеет больше общего с предложением else оператора try, чем с предложением if: предложение else оператора try выполняется, когда не происходит исключения, а предложение else цикла выполняется, когда нет прерывания. имеет место. Дополнительные сведения об операторе try и исключениях см. в разделе Обработка исключений.

## Оператор continue

Оператор continue, также заимствованный из C, продолжает следующую итерацию цикла:

```python
>>> for num in range(2, 10):
...     if num % 2 == 0:
...         print("Found an even number", num)
...         continue
...     print("Found an odd number", num)
...
Found an even number 2
Found an odd number 3
Found an even number 4
Found an odd number 5
Found an even number 6
Found an odd number 7
Found an even number 8
Found an odd number 9
```

## Оператор и pass

Оператор pass ничего не делает. Его можно использовать, когда оператор требуется синтаксически, но программа не требует никаких действий. Например:

```python
>>> while True:
...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
...
```

## Список источников

- [An Informal Introduction to Python (python.org)](https://docs.python.org/3/tutorial/introduction.html)
- [More Control Flow Tools (python.org)](https://docs.python.org/3/tutorial/controlflow.html)