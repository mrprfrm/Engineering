---
tags:
  - python
  - operations
aliases:
  - Bitwise operations
related:
  - "[[Язык программирования Python|Python]]"
last updated: 2023-09-16
version: 0.1.1
---
## Двоичная система счисления

Прежде чем переходить к разбору побитовых операций (bitwise operations) следует дать небольшую справку о представлении данных над которым эти операции выполняются.

Каждые число, буква и символ в контексте вычислительной техники хранятся и обрабатываются в виде двоичного (бинарного) представления, иначе говоря в виде набора нолей и единиц.

С точки зрения арифметики, двоичная система счисления отличается от любой иной (десятиричной, шестнадцатиричной и т.д.) исключительно основанием и все арифметические операции над числами в двоичной системе выполняются также как и во всех прочих.

Однако логические операции над числами в не бинарных системах счисления выполняться не могут поскольку алгебра логики предполагает наличие исключительно двух значений `True` и `False`, один и ноль и т.д.

Исходя и того, что зачастую числа в двоичной системе счисления состоят из более чем одной единицы и ноля, логические операции над такими числами выполняются побитово, то есть последовательно над каждой единицей и нолём в двоичном представлении числа.

В Python двоичное представление числа можно получить используя встроенную функцию `bin`:

```Python
bin(105)
>>> "0b1101001"
```

А также используя синтаксис форматируемых строк:

```Python
f"{105:b}"
>>> "1101001"
```

Используя форматируемые строки, мы также можем указать количество бит, что мы хотим отобразить:

```Python
f"{105:08b}"
>>> "01101001"

f"{105:016b}"
>>> "0000000001101001"
```

> Следует заметить, что если количество бит в числе будет превосходить количество бит указанное в формате, отображаться будет число в двоичном виде без нолей перед значением числа.

## Побитовое AND (&)

![[conjunction.png]]

Побитовое `AND` (`&`) производит операцию конъюнкции над двоичным представлением операндов.

$$
105 \land 52 = 32
$$

Операция в двоичном представлении:

$$
1101001 \land 0110100 = 0100000
$$

Операция в Python:

```Python
# 1101001 & 0110100 = 0100000

105 & 52
>>> 32

bin(105 & 52)
>>> "0b100000"

f"{105 & 52:b}"
>>> "100000"
```

## Побитовое OR (|)

![[disjunction.png]]

Побитовое `OR` (`|`) производит операцию дизъюнкции над двоичным представлением операндов.

$$
105 \lor 52 = 125
$$

Операция в двоичном представлении:

$$
1101001 \lor 0110100 = 1111101
$$

Операция в Python:

```Python
# 1101001 | 0110100 = 1111101

105 | 52 
>>> 125

bin(105 | 52) 
>>> "0b1111101"

f"{105 | 52:b}"
>>> "1111101"
```

## Побитовое NOT (~)

![[negation.png]]

Побитовое `NOT` (`~`) производит операцию отрицания над двоичным представление операнда, заменяя единицы на ноли и ноли на единицы.

$$
\overline{105} = 22
$$

Операция в двоичном представлении:

$$
\overline{1101001} = 0010110
$$
Также арифметически данное преобразование можно выразить как вычитание каждого отдельного бита из единицы

$$
\overline{a_{i}} = 1 - a_{i}
$$

> Следует заметить, что подобное преобразование справедливо исключительно для **беззнаковых** целых чисел, то есть исключительно положительных целых чисел.

В Python побитовое `NOT` может вернуть совершенно неожиданный результат:

```Python
# ~1101001 = -1101010

~105
>>> -106

bin(~105) 
>>> "-0b1101010"

f"{~105:b}"
>>> "-1101010"
```

Дело в том, что в Python используются **знаковые** целые числа, то есть и отрицательные и положительные целые числа, из-за чего результат возвращаемый данной операцией может отличаться от ожидаемого.

Исправить данную ситуацию можно проведя дополнительную операцию конъюнкции с числом той же длинны что и операнд, состоящее в двоичном представлении исключительно из единиц:

```Python
# -1101010 & 1111111 return 0010110

~105 & 127 
>>> 22

bin(~105 & 127) 
>>> "0b10110"

f"{~105 & 127:b}"
>>> "10110"
```

## Побитовое XOR (^)

![[xor.png]]

Побитовое `XOR` (`^`) работает как `OR`, однако для случаев когда `a = 1` и `b = 1` оператор возвращает ноль.

$$
105 \oplus 52 = 93 
$$

Операция в двоичном представлении:

$$
1101001 \oplus 0110100 = 1011101
$$

`XOR` возможно выразить используя другие операторы:

$$
(a \land \overline{b}) \lor (\overline{a} \land b) 
$$

Операция в Python:

```Python
# 1101001 | 0110100 = 1011101

105 ^ 52 
>>> 93

bin(105 | 52) 
>>> "0b1011101"

f"{105 | 52:b}"
>>> "1011101"
```

## Битовый сдвиг влево (<<)

![[bitwise_left_shift.png]]

Оператор битового сдвига влево (`<<`) перемещает биты первого операнда влево на количество позиций, указанное во втором операнде.

$$
105 \ll 1 = 210
$$

Операция в двоичном представлении:

$$
1101001 \ll 1 = 11010010
$$

Также арифметически данное преобразование можно выразить как произведение первого операнда и двойки в степени второго операнда.

$$
a \ll b = a * 2^{b}
$$

Операция в Python:

```Python
# 1101001 << 1 = 10111010

105 << 1
>>> 210

bin(105 << 1) 
>>> "0b10111010"

f"{105 << 1:b}"
>>> "10111010"
```

## Битовый сдвиг вправо (>>)

![[bitwise_right_shift.png]]

Оператор битового сдвига вправо (`>>`) перемещает биты первого операнда вправо на количество позиций, указанное во втором операнде.

Операция в двоичном представлении:

$$
1101001 \gg 1 = 0110100
$$

Также арифметически данное преобразование можно выразить как частное первого операнда и двойки в степени второго операнда без остатка.

$$
a \gg b = \lfloor \frac{a}{2^{b}} \rfloor
$$

```Python
# 1101001 >> 1 = 10111010

105 >> 1
>>> 52

bin(105 >> 1) 
>>> "0b110100"

f"{105 << 1:b}"
>>> "110100"
```

## Список источников

- [Bitwise Operators in Python (realpython.com)](https://realpython.com/python-bitwise-operators/);
- [6.6. Unary arithmetic and bitwise operations (docs.python.org)](https://docs.python.org/3/reference/expressions.html?highlight=bitwise#unary-arithmetic-and-bitwise-operations);
- [6.8. Shifting operations (docs.python.org)](https://docs.python.org/3/reference/expressions.html?highlight=bitwise#shifting-operations);
- [6.9. Binary bitwise operations (docs.python.org)](https://docs.python.org/3/reference/expressions.html?highlight=bitwise#binary-bitwise-operations "Permalink to this headline").