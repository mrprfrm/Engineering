---
aliases:
  - Conditions and match statement
authors:
  - Anton Petrov
status: Draft
tags:
  - python
  - conditions
---
## Условия

Оператор `if` — условный оператор, пожалуй, один из самых часто используемых операторов в программировании. Давайте рассмотрим простейший пример программы:

```python
>>> x = int(input("Please enter an integer: "))
Please enter an integer: 42
>>> if x < 0:
...     x = 0
...     print('Negative changed to zero')
... elif x == 0:
...     print('Zero')
... elif x == 1:
...     print('Single')
... else:
...     print('More')
...
More
```

Оператор `if` — это обязательная часть любого условия, точка входа в блок кода, который будет выполнен только в случае если выражение после `if` истинно.

Оператор `elif` (сокращение от `else if`) — определяет дополнительное условие, которое будет проверено в случае, если предыдущее условие в цепочке оказалось ложным. В контексте цепочки условий мы можем определить сколько угодно много дополнительных условий `elif` или вовсе не иметь ни одного.

Оператор `else` — определяет блок кода, который будет выполнен только в случае, если все предыдущие условия в цепочке оказались ложными. Мы можем определить только один блок `else` или вообще не иметь такого блока в контексте цепочки условий.

В Python последовательность условий `if... elif... elif...` заменяет операторы `switch... case...`, которые можно встретить в других языках.

Для сравнения одного входного значения с константами или типами в Python можно использовать оператор `match`.

## Совпадения

Оператор match принимает выражение и сравнивает его значение с последовательными шаблонами, представленными как один или несколько блоков case. Это поверхностно похоже на оператор switch в C, Java или JavaScript (и многих других языках), но это больше похоже на сопоставление с образцом в языках типа Rust или Haskell. Выполняется только первый шаблон, который соответствует, и также можно извлекать компоненты (элементы последовательности или атрибуты объекта) из значения в переменные.

Простейшая форма сравнивает значение субъекта с одним или несколькими литералами:

```python
def http_error(status):
    match status:
        case 400:
            return "Неверный запрос"
        case 404:
            return "Не найдено"
        case 418:
            return "Я - чайник"
        case _:
            return "Что-то не так с интернетом"
```

Обратите внимание на последний блок: "переменное имя" _ действует как подстановочный знак и всегда соответствует. Если ни один из случаев не соответствует, ни одна из веток не выполняется.

Вы можете объединить несколько литералов в один шаблон с помощью | ("или"):

```python
case 401 | 403 | 404:
    return "Не разрешено"
```

Шаблоны могут выглядеть как распаковочные присваивания и могут использоваться для привязки переменных:

```python
# point - это кортеж (x, y)
match point:
    case (0, 0):
        print("Начало координат")
    case (0, y):
        print(f"Y={y}")
    case (x, 0):
        print(f"X={x}")
    case (x, y):
        print(f"X={x}, Y={y}")
    case _:
        raise ValueError("Не точка")
```

Тщательно изучите это! Первый шаблон имеет два литерала и может рассматриваться как расширение показанного выше литерального шаблона. Но следующие два шаблона объединяют литерал и переменную, и переменная связывает значение из субъекта (point). Четвертый шаблон захватывает два значения, что делает его концептуально аналогичным распаковочному присваиванию (x, y) = point.

Если вы используете классы для структурирования данных, вы можете использовать имя класса, за которым следует список аргументов, напоминающий конструктор, но с возможностью захвата атрибутов в переменные:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def where_is(point):
    match point:
        case Point(x=0, y=0):
            print("Начало координат")
        case Point(x=0, y=y):
            print(f"Y={y}")
        case Point(x=x, y=0):
            print(f"X={x}")
        case Point():
            print("Где-то еще")
        case _:
            print("Не точка")
```

Вы можете использовать позиционные параметры с некоторыми встроенными классами, которые обеспечивают упорядочение для своих атрибутов (например, dataclasses). Вы также можете определить определенное положение для атрибутов в шаблонах, установив специальный атрибут __match_args__ в ваших классах. Если он установлен в ("x", "y"), следующие шаблоны равнозначны (и все они связывают атрибут y с переменной var):

```python
Point(1, var)
Point(1, y=var)
Point(x=1, y=var)
Point(y=var, x=1)
```

Рекомендуемый способ прочитать шаблоны - рассматривать их как расширенную форму того, что вы бы поставили слева от присваивания, чтобы понять, какие переменные будут установлены во что. Только автономные имена (как var выше) устанавливаются оператором match. Точечные имена (например, foo.bar), имена атрибутов (x= и y= выше) или имена классов (определенные по «(...)» рядом с ними, как Point выше) никогда не устанавливаются.

Шаблоны могут быть произвольно вложенными. Например, если у нас есть короткий список точек с добавленным __match_args__, мы можем сопоставить его так:

```python
class Point:
    __match_args__ = ('x', 'y')
    def __init__(self, x, y):
        self.x = x
        self.y = y

match points:
    case []:
        print("Нет точек")
    case [Point(0, 0)]:
        print("Начало координат")
    case [Point(x, y)]:
        print(f"Одна точка {x}, {y}")
    case [Point(0, y1), Point(0, y2)]:
        print(f"Две на оси Y на {y1}, {y2}")
    case _:
        print("Что-то еще")
```

Мы можем добавить условие if к шаблону, известное как "страж". Если страж ложен, опер

атор match переходит к следующему блоку case. Обратите внимание, что захват значения происходит перед оценкой стража:

```python
match point:
    case Point(x, y) if x == y:
        print(f"Y=X на {x}")
    case Point(x, y):
        print(f"Не на диагонали")
```

Еще несколько ключевых особенностей этого оператора:

- Как при распаковочных присваиваниях, кортежи и списки имеют точно такое же значение и фактически соответствуют произвольным последовательностям. Важное исключение состоит в том, что они не соответствуют итераторам или строкам.

- Шаблоны последовательностей поддерживают расширенную распаковку: [x, y, *rest] и (x, y, *rest) работают аналогично распаковочным присваиваниям. Имя после * также может быть _, так что (x, y, *_) соответствует последовательности как минимум из двух элементов, не привязывая остальные элементы.

- Шаблоны словарей: {"bandwidth": b, "latency": l} захватывает значения "bandwidth" и "latency" из словаря. В отличие от шаблонов последовательностей, дополнительные ключи игнорируются. Также поддерживается распаковка **rest. (Но **_ будет избыточным, поэтому это не разрешается.)

- Подшаблоны могут быть захвачены с использованием ключевого слова as:

```python
case (Point(x1, y1), Point(x2, y2) as p2): ...
```

захватит второй элемент ввода как p2 (пока ввод является последовательностью из двух точек)

- Большинство литералов сравниваются по равенству, однако одиночные элементы True, False и None сравниваются по идентичности.

- Шаблоны могут использовать именованные константы. Они должны быть точечными именами, чтобы они не интерпретировались как переменные для захвата:

```python
from enum import Enum
class Color(Enum):
    RED = 'red'
    GREEN = 'green'
    BLUE = 'blue'

color = Color(input("Введите ваш выбор 'red', 'blue' или 'green': "))

match color:
    case Color.RED:
        print("Вижу красный!")
    case Color.GREEN:
        print("Трава зеленая")
    case Color.BLUE:
        print("Мне грустно :(")
```

Для более подробного объяснения и дополнительных примеров вы можете посмотреть PEP 636, который написан в формате учебника.

## Список источников

- [More Control Flow Tools (python.org)](https://docs.python.org/3/tutorial/controlflow.html)
- [Structural Pattern Matching: Tutorial (PEP 636)](https://peps.python.org/pep-0636/)