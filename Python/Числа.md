---
aliases:
  - Numbers
authors:
  - Anton Petrov
tags:
  - python
  - numbers
status: Topic
---
Числа и операции над ними лежат в основе любого языка программирования, и Python не является исключением. В этом языке числовые типы и их операции составляют фундамент для более сложных вычислений и алгоритмов.

Python поддерживает различные числовые типы, такие как целые числа, числа с плавающей запятой и комплексные числа. Каждый тип реализует собственные методы для выполнения арифметических и логических операций. Эти методы, называемые "магическими", обеспечивают совместимость и правильное поведение при работе с числами.

В данной статье рассматриваются базовые числовые типы Python и соответствующие им операции и функции. Цель — систематизировать знания о числах в Python, понимание их поведения и особенностей работы с ними.

## Целые числа

В Python за хранение и выполнение операций над целыми числами отвечает тип `int`. Он поддерживает арифметические операции между базовыми числовыми типами, а также может участвовать в операциях с другими типами Python. Числа типа `int` могут быть представлены любым [[#^e62f39|целочисленным литералом]].

Для примера рассмотрим выражение, содержащее базовые арифметические операции над целыми числами:

```python
>>> 2 + 2 * 6 / 3 - 4
2.0
```

> Следует заметить, что операция деления (`/`) для целых чисел всегда возвращает число с плавающей запятой.

Арифметические операции в Python выполняются с учётом их приоритета. Для изменения порядка выполнения операций в выражении можно использовать круглые скобки:

```python
>>> (2 + 2) * 6 / (3 - 4)
-24.0
```

Далее рассмотрим операции возведения в степень (`**`), целочисленного деления (`//`) и деления по модулю (`%`):

```python
>>> 17 // 3  # целочисленное деление возвращает целую часть от деления
5
>>> 17 % 3  # деление по модулю возвращает остаток от деления
2
>>> 5 ** 2  # 5 в квадрате
25
>>> 2 ** 7  # 2 в 7-й степени
128
>>> 16 ** 0.5 # квадратный корень из 16
4.0
```

Также Python поддерживает некоторые операции между последовательностями и целыми числами:

```python
>>> "repeadme" * 5 # операция умножения строки
"repeadmerepeadmerepeadmerepeadmerepeadme"
>>> (1, 2, 3, 4, 5) * 3 # операция умножения кортежа
(1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5)
```

## Числа с плавающей запятой

В Python тип `float` отвечает за хранение и выполнение операций над числами с плавающей запятой. Он также поддерживает арифметические операции, но в отличие от `int`, может участвовать только в операциях между [[#^57ff51|базовыми числовыми типами]]. Числа такого типа могут быть представлены любым [[#^a4efec|литералом с плавающей запятой]].

Для примера рассмотрим выражение, содержащее базовые арифметические операции над числами с плавающей запятой:

```python
>>> 0.4 + 1.8 * 4.5 / 0.9 - 4.8
5.000000000000001
```

> Неожиданный ответ, откуда взялась лишняя `0.000000000000001`? Это распространённая проблема двоичного представления десятичных дробей в памяти компьютера. Подробнее здесь: [[Аппроксимация чисел с плавающей запятой]].

Теперь рассмотрим выражение, где определим порядок выполнения операций самостоятельно, используя круглые скобки:

```python
>>> (0.4 + 1.8) * 4.5 / (0.9 - 1.8)
-11.0
```

> В данном случае в ответе нет лишних знаков после запятой, поскольку число `11.0` имеет точное представление в двоичной системе счисления. Однако иногда значимая дробная часть числа может просто опускаться ввиду недостаточной точности типа `float`. Для таких случаев используется модуль `decimal`. Подробнее здесь: [[Десятичные дроби]].

Далее рассмотрим операции возведения в степень (`**`), целочисленного деления (`//`) и деления по модулю (`%`):

```python
>>> 14.4 // 1.6 # целочисленное деление возвращает целую часть от деления
8.0
>>> 7.5 % 3.5  # деление по модулю возвращает остаток от деления
0.5
>>> 4 ** 3.5  # 4 в степени 3.5
128.0
>>> 10.24 ** 0.5 # квадратный корень из 10.24
3.2
```

Также тип `float` включает в себя специальные значения `inf` и `NaN`. Сперва рассмотрим арифметические операции с `inf`:

```python
>>> inf = float("inf")
>>> 4 + inf
inf
>>> 8 - inf
-inf
>>> 15 * inf
inf
>>> 16 / inf
0.0
>>> 23 % inf 
23.0
>>> 42 // inf 
0.0
>>> 12 ** inf
inf
```

Теперь рассмотрим выражение с несколькими бесконечностями:

```python
>>> 1 + inf + 2 - inf + 3 * inf + 4 // inf
nan
```

> Операции вычитания или деления между бесконечностями возвращают `NaN`. **NaN (Not a Number)** — не числовое значение, любая арифметическая операция с ним вернёт `NaN`.

Также тип `float` поддерживает метод `is_integer`, что позволяет определить, является ли содержимое переменной типа `float` целым числом:

```python
>>> a = 12.0
>>> a.is_integer()
True
>>> b = 3.14
>>> b.is_integer()
False
>>> c = float("inf")
>>> c.is_integer()
False
```

## Комплексные числа

Тип `complex` в Python отвечает за хранение и выполнение операций над комплексными числами. Он поддерживает арифметические операции только между [[#^57ff51|базовыми числовыми типами]]. Числа такого типа могут быть представлены любым [[#^d4d08c|мнимым литералом]].

Для примера рассмотрим выражение, содержащее базовые арифметические операции над комплексными числами:

```python
>>> (1 + 3j) + (2.4 + 3.2j) * 5j / (2 + 2j) - 4j
6j
```

> Следует заметить, что вещественная и мнимая часть комплексного числа всегда являются числами с плавающей запятой.

Также в выражении с комплексными числами мы можем определить порядок выполнения операций, используя круглые скобки:

```python
>>> (1 + 3j + 2.4 + 3.2j) * 5j / (2 + 2j - 4j)
(-12-3.5j)
```

Комплексные числа не поддерживают операции целочисленного деления (`//`) и деления по модулю (`%`), а операция возведения в степень (`**`) выполняется по правилам возведения в степень двучлена.

```python
>>> (3 + 2j) ** 2
(5+12j)
>>> (16 + 0j) ** 0.5
(4+0j)
```

> Мнимая единица — это фактически корень из отрицательного числа, как следствие квадрат мнимой единицы будет равен `-1`, например:
> $2j^2 = 2^2 * j^2 = 4 * (-1) = -4$

> Теперь подробнее рассмотрим возведение в квадрат комплексного числа:
> $(3 + 2j)^2 = 3^2 + 2 * 3 * 2j + 2j^2 = 9 + 12j - 4 = 5 + 12j$

## Приведение числовых типов

В Python, когда арифметические операции выполняются над числами с отличными типами, эти числа приводятся к общему типу согласно правилам:

- Если одно из чисел является комплексным, второе преобразуется в комплексное;
- В противном случае, если одно из чисел является числом с плавающей запятой, то второе преобразуется в число с плавающей запятой;
- В противном случае оба числа должны быть целыми, и преобразование не требуется.

> Следует заметить, что подобные правила работают только для операторов, чьё описание явно гласит, что "числовые аргументы операции приводятся к общему типу".

Преобразование чисел в результате выполнения операции над ними можно считать **неявным приведением типов**, то есть приведением без явного преобразования типов в коде. **Явное приведение типов** предполагает вызов специальных функций или методов в коде программы, преобразующих один тип в другой.

### Приведение к целому числу

Функция `int` приводит любой подходящий для этого тип к целому типу, такой тип должен реализовывать метод `__int__`. Рассмотрим пример:

```python
class CustomInteger:
	def __init__(self, value):
		self._value = value
	
	def __int__(self):
		return int(self._value)
```

> Метод `__int__` реализуется для приведения [[#^83abe4|пользовательского типа]] данных к типу данных `int` при помощи соответствующей функции. Он может содержать дополнительную логику, но всегда должен возвращать целое число, в противном случае мы получим ошибку.

В Python есть несколько встроенных типов, приводимых к целому числу: 

- Целые числа;
- Строки, представляющие корректные целые числа; 
- Числа с плавающей запятой; 
- Булевые значения.

```python
>>> int(314e-2)
3
>>> int("4815")
4815
>>> int(12.7)
12
>>> int(True)
1
```

> В процессе приведения числа к целому его дробная часть опускается без округления. 

Также функция `int` принимает опциональный аргумент `base`, что позволяет определить систему счисления при приведении чисел:

```python
>>> int("A5", base=16)
165
>>> int("0xa", base=0)
10
```

> `base`, равная `0`, ожидает наличие префикса в записи чисел в недесятичной системе счисления: `0b`/`0o`/`0x` — для двоичных, восьмеричных и шестнадцатеричных чисел соответственно.

Ещё к целому числу можно привести байтовые строки и байтовые массивы, используя метод класса `from_bytes`:

```python
>>> int.from_bytes(b'\x00\x10', byteorder='big')
16
>>> int.from_bytes(b'\x00\x10', byteorder='little')
4096
```

Аргумент `byteorder` определяет порядок байтов, используемый для представления целого числа: `big` — для наиболее значимых байтов в начале байтового массива или строки, `little` — для наиболее значимых байтов в конце.

### Приведение к числу с плавающей запятой

Функция `float` приводит любой подходящий для этого тип к числу с плавающей запятой, такой тип должен реализовывать метод `__float__`. Рассмотрим пример:

```python
class CustomFloat:
	def __init__(self, value):
		self._value = value
		
	def __float__(self):
		return float(self._value)
```

> Метод `__float__` реализуется для приведения [[#^83abe4|пользовательского типа]] данных к типу данных `float` при помощи соответствующей функции. Он может содержать дополнительную логику, но всегда должен возвращать число с плавающей точкой, в противном случае мы получим ошибку.

В Python есть несколько встроенных типов, приводимых к числу с плавающей запятой:

- Числа с плавающей запятой;
- Строки, представляющие корректные числа с плавающей запятой; 
- Целые числа;
- Булевые значения.

```python
>>> float(6.62)
6.62
>>> float("3.14")
3.14
>>> float(42)
42.0
>>> float(False)
0.0
```

### Приведение к комплексному числу

Функция `complex` приводит любой подходящий для этого тип к комплексному числу, такой тип должен реализовывать метод `__complex__`. Рассмотрим пример:

```python
class CustomComplex:
    def __init__(self, real, imag):
        self._real = real
        self._imag = imag
    
    def __complex__(self):
        return complex(self._real, self._imag)
```

> Метод `__complex__` реализуется для приведения [[#^83abe4|пользовательского типа]] данных к типу данных `complex` при помощи соответствующей функции. Он может содержать дополнительную логику, но всегда должен возвращать комплексное число, в противном случае мы получим ошибку.

В Python есть несколько встроенных типов, приводимых к комплексному числу:

- Комплексные числа;
- Строки, представляющие корректные комплексные числа;
- Целые числа;
- Числа с плавающей запятой;
- Булевые значения;
- Кортежи;
- Списки.

```python
>>> complex(1+2j)
(1+2j)
>>> complex("2+3j")
(2+3j)
>>> complex(10)
(10+0j)
>>> complex(3.14)
(3.14+0j)
>>> complex(True)
(1+0j)
>>> complex((5, -2))
(5-2j)
>>> complex([7, 4])
(7+4j)
```

## Логические операции

Python также поддерживает операции сравнения для чисел. Сравниваемые числа могут иметь отличные друг от друга типы. В свою очередь, результаты сравнения могут комбинироваться в логические выражения с помощью соответствующих операторов: `and`, `or` и `not`.

Рассмотрим логическое выражение с операциями сравнения чисел:

```python
>>> 24 > 11.5 >= 11.5 or 3.14 == 3 != 4.0 and 12 < 24.75 <= 31.4
True
```

> Следует заметить, что не все числовые типы поддерживают операции сравнения. Например, комплексные числа можно сравнивать только по модулю, что вполне логично, учитывая концепцию мнимой единицы.

Также Python поддерживает сравнение экземпляров объектов по их ссылкам с использованием операторов `is` и `is not`.

```python
>>> 8 is 8
True
>>> 8 is not 8.0
True
```

> В данном случае сравниваются не значения чисел, а ссылки на ячейки памяти, где эти числа находятся. Такое сравнение будет справедливо только для чисел одного типа и, как правило, происходит быстрее.

## Функции для работы с числами

В Python существует ряд встроенных функций для работы с числовыми типами. Некоторые из них представляют собой более эффективную альтернативу операторам, другие позволяют выполнять вычисления, недоступные через операторы. Python также позволяет определить собственные типы, поддерживающие встроенные функции для работы с числами.

### Абсолютное значение чисел

Функция `abs` возвращает абсолютное значение (значение по модулю) для любого подходящего для этого типа, который должен реализовывать метод `__abs__`.

```python
class CustomComplex:
	def __init__(self, rel, img):
		self._rel = rel
		self._img = img
	
	def __abs__(self):
		return (self._rel ** 2 + self._img ** 2) ** 0.5
```

Функция `abs` поддерживается [[#^9e4aa4|числовыми типами стандартной библиотеки]]. Рассмотрим пример с базовыми типами:

```python
>>> abs(-481) # абсолютное значение целого числа
481
>>> abs(-523.42) # абсолютное значение числа с плавающей точкой
523.42
>>> abs(3 + 4j) # абсолютное значение комплексного числа
5.0
```

> Абсолютное значение комплексного числа рассчитывается по формуле  $\sqrt{a^2 + b^2}$, где `a` — вещественная часть числа, `b` — мнимая часть числа.

### Округление чисел

За округление чисел в Python отвечает функция `round`. Она округляет число любого подходящего для этого типа до заданной точности, такой тип должен реализовывать метод `__round__`.

```python
class CustomFloat:
	def __init__(self, value):
		self._value = value
		
	def __round__(self, ndigits=0):
		pass
```

Функция `round` принимает два аргумента: `number` — число, которое будет округлено; `ndigits` — количество знаков после запятой, этот аргумент является опциональным. Рассмотрим пример со встроенными типами:

```python
>>> round(12, 3) # округление целого числа просто вернёт исходное значение
12
>>> round(3.14, 1)
3.1
```

> Функция `round` поддерживается некоторыми [[#^9e4aa4|числовыми типами стандартной библиотеки]], однако не поддерживается комплексными числами.

### Возведение в степень

Функция `pow` используется для возведения числа в степень, аналогично оператору `**`. Однако `pow` может принимать опциональный аргумент `mod`, что позволяет найти [[#^581af4|обратное по модулю число]].

```python
>>> pow(10, 2) # здесь мы получим целое число, основа и степень целые и положительные
100
>>> pow(10, -2) # теперь ответ будет числом с плавающей запятой, поскольку степень отрицательная
0.01
>>> pow(-9, 0.5) # в данном случае мы получим комплексное число близкое к (3j)
(1.8369701987210297e-16+3j)
>>> pow(-9, 2.0) # результат будет числом с плавающей запятой
81.0
```

> Подобные закономерности применимы к любым значениям, аналогичным приведённым примерам.

Теперь рассмотрим нахождение обратного по модулю числа для данного числа при помощи функции `pow`.

```python
>>> pow(38, -1, mod=97) # найдём обратное по модулю 97 число для числа 38
23 
>>> 23 * 38 % 97 == 1 # проверим результат на равенство по модулю
True
```

Следует заметить, что использование функции `pow` является не только самым эффективным, но и самым простым способом нахождения таких чисел без необходимости использовать [[Обыкновенные дроби|обыкновенные дроби]]. Рассмотрим пример аналогичного решения при помощи операторов:

```python
>>> 38 ** -1 % 97
0.02631578947368421
```

> В данном случае мы снова столкнулись с проблемой [[Аппроксимация чисел с плавающей запятой|аппроксимации чисел с плавающей запятой]], как следствие, полученный результат не будет удовлетворять равенству по модулю и не будет корректным.

### Деление по модулю

Функция `divmod` возвращает пару чисел: результат от деления без остатка и остаток от деления. Функция аналогична выражению: `quotient, remainder = a // b, a % b`, однако она не только более лаконична, но и эффективна.

```python
>>> divmod(125, 60) # найдём количество целых минут и секунд в 125 секундах
(2, 5)
```

> Также `divmod` идеально подходит для нахождения наибольшего общего делителя.

## Сноски

**Базовые (distinct) числовые типы** — в данном случае, это оригинальные, не производные ни от одного другого типа числовые типы данных, такие как `int`, `float` и `complex`. ^57ff51

**Числовые типы стандартной библиотеки** — помимо исходных `int`, `float` и `complex`, к таким типам также относятся булевый тип (`bool`), десятичные дроби (модуль `decimal`), а также обыкновенные дроби (модуль `fractions`). ^9e4aa4

**Пользовательские (custom) типы** — это классы, определённые в контексте сторонних библиотек или в коде программы. ^83abe4

**Целочисленный литерал** — это число, буква или сочетание букв и чисел, соответствующие определённой системе счисления, а также символ `_` в записи числа, например: `1`, `24`, `0b01101`, `0xC5`, `10_000_000` и так далее. ^e62f39

**Литерал с плавающей запятой** — это любая десятичная дробь, экспоненциальная запись числа (`21e-2` = `0.21`), а также символ `_` в записи числа, например: `"3.14"`, `"10."`, `".001"`, `"3.14e-10"`, `"3.14_15_93"` и так далее. ^a4efec

**Мнимый литерал** — это число или пара целых чисел, чисел с плавающей запятой или экспоненциальная запись чисел, вида `a + bj`, где `a` — это вещественная и `b` — мнимая части комплексного числа, а также символ `_` в записи числа, например: `3.14j`, `10.j`, `10j`, `.001j`, `1e100j`, `3.14e-10j`, `3.14_15_93j`. ^d4d08c

**Обратное по модулю число** — это такое число `x`, что при умножении на данное число `a` по определённому модулю даёт результат равный единице. [[Расширенный алгоритм Эвклида]] описывает нахождение обратных по модулю чисел. Такие числа имеют практическое применение в криптографии, например в [[Алгоритм Диффи-Хелмана|алгоритме Диффи-Хеллмана]]. ^581af4

**Наибольший общий делитель** — это наибольшее целое число, которое делит два или более целых чисел без остатка. [[Алгоритм Эвклида]] описывает нахождение наибольшего общего делителя. Числа с наибольшим общим делителем имеют практическое применение в криптографии, например в [[RSA]]. ^bd4e86

## Список иcточников

- [An Informal Introduction to Python (python.org)](https://docs.python.org/3/tutorial/introduction.html)
- [Built-in Types (python.org)](https://docs.python.org/3/library/stdtypes.html)
- [Built-in Functions (python.org)](https://docs.python.org/3/library/functions.html#built-in-functions)
- [Lexical analysis (python.org)](https://docs.python.org/3/reference/lexical_analysis.html)
- [Expressions (python.org)](https://docs.python.org/3/reference/expressions.html)
- [Numbers in Python (realpython.com)](https://realpython.com/python-numbers)