Зачастую представляется в виде совокупности объектов вида

```Python
class ListNode:
	def __init__(self, val = 0, next = None):
		self.val = val
		self.next = next
```

В данном случае обход связанного списка через цикл `for` не представляется возможным, поскольку объект `ListNode`, без реализации дополнительных интерфейсов, не является итератором, то есть объектом к которому применим цикл `for`.

Однако даже при условии, что `ListNode` не является итератором, обход по связанному списку в данном представлении всё же возможен.

Один из самых простых и очевидных способов перебора объектов со вложенной структурой — реализация рекурсии.

```Python
def loopLinkedList(head):
	// TODO: inner function logic
	if head.next is not None:
		loopLinkedList(head.next)
```

Также в контексте такой рекурсии можно с легкостью привести связанный список к генератору.

```Python
def genLinkedList(head):
	yield head
	if head.next is not None:
		yield from genLinkedList(head.next)
```

> Однако следует заметить, что подобная реализация имеет ограничение на глубину рекурсии и в целом в контексте задачи обхода связанного списка не является оптимальной.

В качестве не менее простой, но более оптимальной и надёжной реализации обхода связанного списка рассмотрим решение через цикл `while`.

```Python
def loopLinkedList(head):
	while head is not None:
		// TODO: inner function logic
		head = head.next
```

В данном случае у нас нет необходимости добавлять дополнительную проверку на пустоту следующего элемента списка, поскольку как только мы достигнем конца списка следующий элемент будет пустым, а цикл, согласно  условию завершится.