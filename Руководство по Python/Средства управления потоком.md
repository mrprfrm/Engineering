---
aliases:
  - Control Flow Tools
author:
  - Anton Petrov
last updated: 2023-11-18
related:
  - "[[Руководство|The Python Tutorial]]"
spell checked: false
tags:
  - python
  - loops
  - conditions
version: 0.0.4
---
Этот раздел более развёрнуто описывает основные средства управления потоком Python — циклы и условия. Также раздел содержит описание полезных функций и инструкций языка, используемых в контексте управления потоком.

## Содержание

- [[#Условия]]
- [[#Цикл for]]
- [[#Функция range]]
- [[#Операторы break и continue]]
- [[#Оператор pass]]

## Условия

Оператор `if` — условный оператор, пожалуй, один из самых часто используемых операторов в программировании. Давайте рассмотрим простейший пример программы:

```python
>>> x = int(input("Please enter an integer: "))
Please enter an integer: 42
>>> if x < 0:
...     x = 0
...     print('Negative changed to zero')
... elif x == 0:
...     print('Zero')
... elif x == 1:
...     print('Single')
... else:
...     print('More')
...
More
```

Оператор `if` — это обязательная часть любого условия, точка входа в блок кода, который будет выполнен только в случае если условия после `if` истинно.

Оператор `elif` (сокращение от `else if`) — определяет дополнительное условие, которое будет проверено в случае, если предыдущее условие в цепочке оказалось ложным. В контексте цепочки условий мы можем определить сколько угодно много дополнительных условий `elif` или вовсе не иметь ни одного.

Оператор `else` — определяет блок кода, который будет выполнен только в случае, если все предыдущие условия в цепочке оказались ложными. Мы можем определить только один блок `else` или вообще не иметь такого блока в контексте цепочки условий.

В Python последовательность условий `if... elif... elif...` заменяет операторы `switch... case...`, которые можно встретить в других языках.

Для сравнения одного входного значения с константами или типами в Python можно использовать оператор `match`.

## Цикл for

Оператор `for` в Python немного отличается от того, к чему вы привыкли в C или Pascal. Вместо того, чтобы постоянно перебирать арифметическую прогрессию чисел (как в Паскале) или давать пользователю возможность определять как шаг итерации, так и условие остановки (как в C), оператор Python for выполняет итерацию по элементам любой последовательности (список или строка) в том порядке, в котором они появляются в последовательности. Например (без каламбура):

```python
>>> # Измерим длинну нескольких строк:
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print(w, len(w))
...
cat 3
window 6
defenestrate 12
```

Код, который изменяет коллекцию во время итерации по той же самой коллекции, может быть сложным для правильного выполнения. Вместо этого обычно проще перебрать копию коллекции или создать новую коллекцию:

```python
# Создадим простой словарь
users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}

# Обойдём копию исходного словаря и удалим некоторые из элементов в оригинальном словаре
for user, status in users.copy().items():
    if status == 'inactive':
        del users[user]

# Создадим новый словарь активных пользователей
active_users = {}
for user, status in users.items():
    if status == 'active':
        active_users[user] = status
```

## Функция range

Если вам нужно перебрать последовательность чисел, вам пригодится встроенная функция range(). Он генерирует арифметические прогрессии:

```python
>>> for i in range(5):
...     print(i)
...
0
1
2
3
4
```

Данная конечная точка никогда не является частью сгенерированной последовательности; range(10) генерирует 10 значений, допустимые индексы для элементов последовательности длиной 10. Можно позволить диапазону начинаться с другого числа или указать другое приращение (даже отрицательное; иногда это называется «шагом»). ):

```python
>>> list(range(5, 10))
[5, 6, 7, 8, 9]

>>> list(range(0, 10, 3))
[0, 3, 6, 9]

>>> list(range(-10, -100, -30))
[-10, -40, -70]
```

> В данном случае мы приводим результат функции `range()` ко списку, поскольку она возвращает итератор вместо списка, что будет расчитываться в процессе обхода через цикл.

Чтобы перебирать индексы последовательности, вы можете объединить `range()` и `len()` следующим образом:

```python
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
```

Однако в большинстве таких случаев удобно использовать функцию enumerate(), см. «Техника работы с циклами».

Во многих отношениях объект, возвращаемый функцией range(), ведет себя так, как будто это список, но на самом деле это не так. Это объект, который возвращает последовательные элементы желаемой последовательности, когда вы перебираете его, но на самом деле он не составляет список, тем самым экономя место.

Мы говорим, что такой объект является итеративным, то есть подходит в качестве цели для функций и конструкций, которые ожидают чего-то, из чего они могут получать последовательные элементы, пока запас не будет исчерпан. Мы видели, что такой конструкцией является оператор for, а примером функции, принимающей итерируемый объект, является sum():

```python
sum(range(4))  # 0 + 1 + 2 + 3
6
```

Позже мы увидим больше функций, которые возвращают итерации и принимают итерации в качестве аргументов. В главе «Структуры данных» мы более подробно обсудим list().

## Операторы break и continue

Оператор Break выходит из самого внутреннего цикла for или while.

Цикл for или while может включать в себя предложение else.

В цикле for предложение else выполняется после того, как цикл достигает последней итерации.

В цикле while он выполняется после того, как условие цикла становится ложным.

В любом типе цикла предложение else не выполняется, если цикл был завершен прерыванием.

Это иллюстрируется следующим циклом for, который ищет простые числа:

```python
>>> for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print(n, 'equals', x, '*', n//x)
...             break
...     else:
...         # loop fell through without finding a factor
...         print(n, 'is a prime number')
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
```

(Да, это правильный код. Посмотрите внимательно: предложение else принадлежит циклу for, а не оператору if.)

При использовании с циклом предложение else имеет больше общего с предложением else оператора try, чем с предложением if: предложение else оператора try выполняется, когда не происходит исключения, а предложение else цикла выполняется, когда нет прерывания. имеет место. Дополнительные сведения об операторе try и исключениях см. в разделе Обработка исключений.

Оператор continue, также заимствованный из C, продолжает следующую итерацию цикла:

```python
>>> for num in range(2, 10):
...     if num % 2 == 0:
...         print("Found an even number", num)
...         continue
...     print("Found an odd number", num)
...
Found an even number 2
Found an odd number 3
Found an even number 4
Found an odd number 5
Found an even number 6
Found an odd number 7
Found an even number 8
Found an odd number 9
```

## Оператор pass

Оператор pass ничего не делает. Его можно использовать, когда оператор требуется синтаксически, но программа не требует никаких действий. Например:

```python
>>> while True:
...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
...
```

Обычно это используется для создания минимальных классов:

```python
>>> class MyEmptyClass:
...     pass
...
```

Другой проход места можно использовать в качестве заполнителя для функции или условного тела, когда вы работаете над новым кодом, что позволяет вам продолжать думать на более абстрактном уровне. Пропуск молча игнорируется:

```python
def initlog(*args):
...     pass   # Remember to implement this!
...
```