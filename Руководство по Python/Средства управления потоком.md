---
aliases:
  - Control Flow Tools
author:
  - Anton Petrov
last updated: 2023-11-18
related:
  - "[[Руководство|The Python Tutorial]]"
spell checked: false
tags:
  - python
  - loops
  - conditions
version: 0.0.5
---
Этот раздел более развёрнуто описывает основные средства управления потоком Python — циклы и условия. Также раздел содержит описание полезных функций и инструкций языка, используемых в контексте управления потоком.

## Содержание

- [[#Условия]]
- [[#Цикл for]]
- [[#Функция range]]
- [[#Операторы break и continue]]
- [[#Оператор pass]]

## Условия

Оператор `if` — условный оператор, пожалуй, один из самых часто используемых операторов в программировании. Давайте рассмотрим простейший пример программы:

```python
>>> x = int(input("Please enter an integer: "))
Please enter an integer: 42
>>> if x < 0:
...     x = 0
...     print('Negative changed to zero')
... elif x == 0:
...     print('Zero')
... elif x == 1:
...     print('Single')
... else:
...     print('More')
...
More
```

Оператор `if` — это обязательная часть любого условия, точка входа в блок кода, который будет выполнен только в случае если выражение после `if` истинно.

Оператор `elif` (сокращение от `else if`) — определяет дополнительное условие, которое будет проверено в случае, если предыдущее условие в цепочке оказалось ложным. В контексте цепочки условий мы можем определить сколько угодно много дополнительных условий `elif` или вовсе не иметь ни одного.

Оператор `else` — определяет блок кода, который будет выполнен только в случае, если все предыдущие условия в цепочке оказались ложными. Мы можем определить только один блок `else` или вообще не иметь такого блока в контексте цепочки условий.

В Python последовательность условий `if... elif... elif...` заменяет операторы `switch... case...`, которые можно встретить в других языках.

Для сравнения одного входного значения с константами или типами в Python можно использовать оператор `match`.

## Цикл for

Цикл `for` в Python предназначен исключительно для работы с итераторами. В нём последовательно перебираются элементы итератора, вплоть до момента, когда в нём не останется необработанных элементов, тогда цикл завершает свою работу и возвращает управление в основной поток программы.

Такой подход отличается от реализации циклов в некоторых других языках, описывающих арифметическую прогрессию (как в Pascal) или определяющих шаг итерации и условие выхода из цикла (как в C). 

```python
>>> # Измерим длинну нескольких строк:
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print(w, len(w))
...
cat 3
window 6
defenestrate 12
```

> В Python также доступен цикл `while`. Он реализует принципиально отличный поход — код внутри цикла `while` будет выполняться до тех пока, пока выражение в определении цикла будет истинно.

> TODO: как нибудь подвести к задаче модификации, а то как то с какой стати мы вообще эту задачу разбираем

Теперь рассмотрим решение по модификации исходной последовательности в цикле. В данном случае мы обходим словарь — последовательность пар ключ-значение фиксированной длинны и любое изменение длинны словаря во время его обхода приведёт к ошибке: `RuntimeError: dictionary changed size during iteration`. Поэтому для данного решения мы используем копию словаря.

```python
# Создадим простой словарь
users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}

# Обойдём копию исходного словаря и удалим некоторые из элементов в исходном словаре
for user, status in users.copy().items():
    if status == 'inactive':
        del users[user]

# Создадим новый словарь активных пользователей
active_users = {}
for user, status in users.items():
    if status == 'active':
        active_users[user] = status
```

## Функция range

В случае, когда задача сводится к перебору чисел, например индексов в заданном диапазоне, мы можем использовать лаконичный синтаксис цикла `for` в комбинации с функцией `range()`.

Функция `range()` возвращает арифметическую последовательность чисел:

```python
>>> for i in range(5):
...     print(i)
...
0
1
2
3
4
```

`range(1, 5) + range(5, 10) = range(1, 10)`

Данная конечная точка никогда не является частью сгенерированной последовательности; range(10) генерирует 10 значений, допустимые индексы для элементов последовательности длиной 10. Можно позволить диапазону начинаться с другого числа или указать другое приращение (даже отрицательное; иногда это называется «шагом»). ):

```python
>>> list(range(5, 10))
[5, 6, 7, 8, 9]

>>> list(range(0, 10, 3))
[0, 3, 6, 9]

>>> list(range(-10, -100, -30))
[-10, -40, -70]
```

> В данном случае мы приводим результат функции `range()` ко списку, поскольку она возвращает итератор вместо списка, что будет расчитываться в процессе обхода через цикл.

Чтобы перебирать индексы последовательности, вы можете объединить `range()` и `len()` следующим образом:

```python
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
```

> В большинстве случаев в место `range()` уместнее использовать функцию `enumerate()`, что принимает на вход любой итератор в возвращает последовательность пар индекс-значение.

Во многих отношениях объект, возвращаемый функцией range(), ведет себя так, как будто это список, но на самом деле это не так. Это объект, который возвращает последовательные элементы желаемой последовательности, когда вы перебираете его, но на самом деле он не составляет список, тем самым экономя место.

Мы говорим, что такой объект является итеративным, то есть подходит в качестве цели для функций и конструкций, которые ожидают чего-то, из чего они могут получать последовательные элементы, пока запас не будет исчерпан. Мы видели, что такой конструкцией является оператор for, а примером функции, принимающей итерируемый объект, является sum():

```python
sum(range(4))  # 0 + 1 + 2 + 3
6
```

Позже мы увидим больше функций, которые возвращают итерации и принимают итерации в качестве аргументов. В главе «Структуры данных» мы более подробно обсудим list().

## Операторы break и continue

Оператор Break выходит из самого внутреннего цикла for или while.

Цикл for или while может включать в себя предложение else.

В цикле for предложение else выполняется после того, как цикл достигает последней итерации.

В цикле while он выполняется после того, как условие цикла становится ложным.

В любом типе цикла предложение else не выполняется, если цикл был завершен прерыванием.

Это иллюстрируется следующим циклом for, который ищет простые числа:

```python
>>> for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print(n, 'equals', x, '*', n//x)
...             break
...     else:
...         # loop fell through without finding a factor
...         print(n, 'is a prime number')
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
```

(Да, это правильный код. Посмотрите внимательно: предложение else принадлежит циклу for, а не оператору if.)

При использовании с циклом предложение else имеет больше общего с предложением else оператора try, чем с предложением if: предложение else оператора try выполняется, когда не происходит исключения, а предложение else цикла выполняется, когда нет прерывания. имеет место. Дополнительные сведения об операторе try и исключениях см. в разделе Обработка исключений.

Оператор continue, также заимствованный из C, продолжает следующую итерацию цикла:

```python
>>> for num in range(2, 10):
...     if num % 2 == 0:
...         print("Found an even number", num)
...         continue
...     print("Found an odd number", num)
...
Found an even number 2
Found an odd number 3
Found an even number 4
Found an odd number 5
Found an even number 6
Found an odd number 7
Found an even number 8
Found an odd number 9
```

## Оператор pass

Оператор pass ничего не делает. Его можно использовать, когда оператор требуется синтаксически, но программа не требует никаких действий. Например:

```python
>>> while True:
...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
...
```

Обычно это используется для создания минимальных классов:

```python
>>> class MyEmptyClass:
...     pass
...
```

Другой проход места можно использовать в качестве заполнителя для функции или условного тела, когда вы работаете над новым кодом, что позволяет вам продолжать думать на более абстрактном уровне. Пропуск молча игнорируется:

```python
def initlog(*args):
...     pass   # Remember to implement this!
...
```

## Список источников

- [More Control Flow Tools](https://docs.python.org/3/tutorial/controlflow.html)
