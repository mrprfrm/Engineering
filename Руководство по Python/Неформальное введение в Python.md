---
aliases:
  - An Informal Introduction to Python
author:
  - Anton Petrov
last updated: 2023-10-29
related:
  - "[[Руководство|The Python Tutorial]]"
spell checked: false
tags:
  - python
version: 0.0.9
---
Этот топик посвящён некоторым основным типам данных Python. Здесь рассматриваются числа, строки и последовательности, а также некоторые встроенные функции и инструменты управления потоком.

## Содержание

-  [[#Числа]]
- [[#Текст]]
	- [[#Форматирование строк]]
	- [[#Индексация строк]]
- [[#Списки]]
- [[#Программы на Python]]
	- [[#Множественное присваивание]]
	- [[#Цикл while]]
	- [[#Форматируемый вывод]]
- [[#Сноски]]
- [[#Список источников]]

## Числа

При работе с числами, интерпретатор Python мало чем отличается от простых калькуляторов. В основном, в промпте мы вводим математическое выражение и нажимаем Enter, а интерпретатор в ответ возвращает результат вычисления введенного выражения.

Python поддерживает все базовые арифметические операции, а также учитывает приоритеты операций, определённые скобками `()`:

```Python
2 + 2
4
>>> 50 - 5 * 6
20
>>> (50 - 5 * 6) / 4
5.0
>>> 8 / 5
1.6 # операция деления всегда возвращает число с плавающей точкой
```

Целые числа в Python имеют тип `int`, а числа с плавающей точкой тип `float`.

Деление (`/`) в Python всегда возвращает число с плавающей точкой. Однако Python также поддерживает операции деления без остатка (`//`) и деления по модулю (`%`):

```Python
>>> 17 / 3  # обычное деление возвращает число с плавающей точкой
5.666666666666667
>>>
>>> 17 // 3  # целочисленное деление возвращает целую часть от деления
5
>>> 17 % 3  # оператор % возвращает остаток от деления
2
>>> 5 * 3 + 2  # целая часть * делитель + остаток от деления
17
```

Ещё Python поддерживает операцию возведения в степень (`**`):

```python
>>> 5 ** 2  # 5 в квадрате
25
>>> 2 ** 7  # 2 в 7ой степени
128
```

Знак равенства в Python — это оператор присваивания. Этот оператор не возвращает никаких значений в промпт, но позволяет присвоить значение переменной:

```python
>>> width = 20
>>> height = 5 * 9
>>> width * height
900
```

Если использовать переменную до её объявления, то это вызовет ошибку:

```python
>>> n  # попробуем обратиться к неопределённой переменной
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'n' is not defined
```

Также Python позволяет выполнять некоторые операции над смешанными типами, например, мы можем  выполнять арифметические операции между целыми числами и числами с плавающей точкой. Результат таких вычислений всегда имеет тип `float`:

```python
>>> 4 * 3.75 - 1
14.0
```

В интерактивном режиме последнее выведенное значение всегда присваивается переменной `_`. Это очень упрощает использование Python в качестве калькулятора, поскольку позволяет продолжать вычисления над последним найденым значением:

```python
>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06
```

В контексте итерактивного режима Python, переменная `_` не должна определяться пользователем. Если мы определим эту переменную самостоятельно, то связанная с ней "магическое" поведение, также будет переопределно и как следствие обращаться к последнему найденному значению в промпте мы больше не сможем.

> Следует заметить, что переменная `_` часто используется в коде как переменная-заглушка, то есть переменная, чьё значение не будет использоваться дальше в коде.

```python
for _ in range(10):
    print("All work and no play makes Jack a dull boy")
```

Помимо типов `int` и `float`, в Python также есть дополнительные числовые типы [Decimal](https://docs.python.org/3/library/decimal.html) и [Fraction](https://docs.python.org/3/library/fractions.html). Также Python из коробки поддерживает комплексные числа и использует `j` или `J` суффикс для обозначения мнимой части (`3 + 5j`).

### Текст

Python также поддерживает текстовый тип данных — строки (`str`) и позволяет выполнять операции над ними.

Строки в Python могут содержать абсолютно любые [[#^187c76|строковые литералы]]: буквы, слова, имена собственные, предложения, знаки препинания, числа и т.д. Также Python позволяет использовать для определения строк как двойные (`""`) так и одиночные (`''`) кавычки:

```python
>>> 'spam eggs'  # одиночные кавычки
'spam eggs'
>>> "Paris rabbit got your back :)! Yay!"  # двойные кавычки
'Paris rabbit got your back :)! Yay!'
>>> '1975'  # цифры и числа, заключённые в кавычки, также являются строками
'1975'
```

### Форматирование строк

Чтобы поместить кавычки внутрь строки в Python мы прежде всего можем использовать разные типы кавычек для объявления строки и внутри неё, но также мы можем экранировать кавычки, если первый вариант нам не подходит. Для этого достаточно добавить символ `\` перед экранируемым символом:

```python
>>> 'doesn\'t'  # используем \' чтобы экранировать кавычку того же типа внутри строки...
"doesn't"
>>> "doesn't"  # ...или используем кавычки разного типа для определения строки и внутри неё
"doesn't"
>>> '"Yes," they said.'
'"Yes," they said.'
>>> "\"Yes,\" they said."
'"Yes," they said.'
>>> '"Isn\'t," they said.'
'"Isn\'t," they said.'
```

В оболочке Python определение строки и её вывод в терминал могут отличаться. Функция `print()` обеспечивает более читаемый вывод, она форматирует его согласно экранированным и специальным символам в исходной строке, а также упраздняет заключающие текст кавычки:

```python
>>> s = 'First line.\nSecond line.'  # символ \n означет перенос строки
>>> s  # без вызова функции print(), специальные символы просто выводятся как часть строки
'First line.\nSecond line.'
>>> print(s)  # внутри функции print(), строка форматируется и выводится с учётом специальных символов
First line.
Second line.
```

Если мы хотим обеспечить вывод без форматирования, то есть отобразить специальные символы и экранированные символы как  они указаны в исходной строке, мы можем использовать специальный тип строк (`r"raw string"`):

```python
>>> print('C:\some\name')  # здесь в строке встретился символ \n, что приведёт к разрыву строки
C:\some
ame
>>> print(r'C:\some\name')  # чтобы избежать ненамеренного форматирования передадим "сырую" строку
C:\some\name
```

У "сырых" строк есть один нюанс — они не могут заканчиваться нечетным количеством символов `\`:

```python
>>> r'C:\this\will\not\work\'
  File "<stdin>", line 1
    r'C:\this\will\not\work\'
         ^
SyntaxError: unterminated string literal (detected at line 1)
```

Обойти это ограничение можно экранировав все символы `\` в строке:

```python
>>> 'C:\\this\\will\\work\\'
'C:\\this\\will\\work\\'
```

Строковые литералы в Python могут занимать несколько строк. Определить такой многострочный текст можно используя тройные кавычки: `"""...."""` или `'''...'''`.  Начало и окончание строки (зачастую переносы строк перед и после текста в строке) также включаются в строку, однако предотвратить это можно, `\` в конце строки. Например:

```python
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")
```

выведет текст:

```python
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
```

> Следует заметить. что пустые строки в начале и в конце строки не включены в вывод.

Python также поддерживает конкатенацию (объединение) строк с помощью оператора сложения, а также повторения строк с помощью оператора умножения:

```python
>>> # выведем 'un' три разв, а затем объединим это с 'ium'
>>> 3 * 'un' + 'ium'
'unununium'
```

Два и долее строковых литерала, расположенные последовательно друг за другом автоматически объединяются:

```python
>>> 'Py' 'thon'
'Python'
```

Эта функция особенно полезна, когда мы хотим разделить длинный текст на набор более компактных строк:

```python
>>> text = ('Put several strings within parentheses '
...         'to have them joined together.')
>>> text
'Put several strings within parentheses to have them joined together.'
```

Однако такой синтаксис поддерживается только для строк, для переменных или иных выражений это вызовет ошибку:

```python
>>> prefix = 'Py'
>>> prefix 'thon'  # автоматическое конкатенация тежду переменными и строками не поддерживается
  File "<stdin>", line 1
    prefix 'thon'
           ^^^^^^
SyntaxError: invalid syntax
>>> ('un' * 3) 'ium'
  File "<stdin>", line 1
    ('un' * 3) 'ium'
               ^^^^^
SyntaxError: invalid syntax
```

Чтобы избежать ошибок для таких случаев, следует определить операцию конкатенации явно, используя оператор сложения:

```python
>>> prefix + 'thon'
'Python'
```

### Индексация строк

Ещё, строки в Python поддерживают индексацию, то есть определяют для каждого символа внутри определённый индекс, по которому затем можно обратиться к символу используя специальный синтаксис. Индексация в Python начинается с `0`. 

Также Python не имеет специального типа данных для символов (как например тип `char` в некоторых языках). Каждый символ в Python — это просто строка длинной в один символ. 

```python
>>> word = 'Python'
>>> word[0]  # символ на позиции 0
'P'
>>> word[5]  # символ на позиции 5
'n'
```

Индексы также могут быть отрицательными, что позволяет обращаться к символам в порядке с права на лево:

```python
>>> word[-1]  # последний символ в строке
'n'
>>> word[-2]  # второй с конца символ в строке
'o'
>>> word[-6]
'P'
```

> Поскольку значения `-0` и `0` равны, отрицательные индексы начинаются с `-1`, а не с `-0`.

Python также позволяет формировать срезы строк, то есть возвращать их подстроки, используя пару индексов начала и конца среза. 

```python
>>> word[0:2]  # срез символов с первго включительно до третьего не включительно
'Py'
>>> word[2:5]  # срез символов со второго включительно до пятого невключительно
'tho'
```

Также срезы позволяют и вовсе опускать индексы, в этом случае подстрока будет сформирована на основе значений по умолчанию. Для начала среза значение по умолчанию равно `0`, для конца среза длине исходной строки.

```python
>>> word[:2]   # срез символов от начала строки до второго невключительно
'Py'
>>> word[4:]   # срез символов с четвёртого включительно до конца строки
'on'
>>> word[-2:]  # срез символов со второго с конца включительно до конца строки
'on'
```

Интересный факт — начало среза всегда включается в итоговую подстроку, а конец никогда не в неё включается. Такое поведение гарантирует, что  `s[:i] + s[i:]` всегда равно `s`:

```python
>>> word[:2] + word[2:]
'Python'
>>> word[:4] + word[4:]
'Python'
```

В Python не возможно обратиться к символу по индексу за пределами строки, это всегда приводит к вызову ошибки.

```python
>>> word[42]  # строка состоит только из шести символов
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
```

Однако это правило совершенно не применимо ко слезам. В Python срез может быть определён в абсолютно любом диапазоне, даже полностью выходящем за рамки исходной строки:

```python
>>> word[4:42]
'on'
>>> word[42:]
''
```

Содержимое строк в Python невозможно изменить, поскольку они [[#^bd5d7c|иммутабельны]]. Любая попытка присвоить новое значение символу в строке по его индексу приведёт к ошибке:

```python
>>> word[0] = 'J'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
>>> word[2:] = 'py'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

Для того, чтобы изменить исходную строку нам необходимо создать новую на её основе, например используя срез:

```python
>>> 'J' + word[1:]
'Jython'
>>> word[:2] + 'py'
'Pypy'
```

А для определения длинны строк Python предоставляет встроенную функцию `len()`:

```python
>>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34
```

## Списки

В Python также поддерживается ряд составных (compound) типов данных, предназначенных для группирования и хранения других значений. Наиболее универсальным из них является список (`list`), который можно определить как список значений, разделённых запятой, заключённых в квадратные скобки.

Списки могут содержать элементы с отличным друг от друга типом, но как правило в контексте одного списка хранятся элементы одного типа.

```python
>>> squares = [1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]
```

Как и строки в Python, списки являются [[#^cea259|последовательностями]] и как все прочие последовательности списки позволяют обращаться ко вложенным элементам по их индексу, а также создавать новые списки используя срезы:

```python
>>> squares[0]  # возвращает элемент списка по индексу
1
>>> squares[-1]
25
>>> squares[-3:]  # создаёт новый список через срез
[9, 16, 25]
```

Операция среза над списком всегда возвращает новый список, согласно индексам среза. Операция среза от начала до конца списка возвращает [[#^e83003|поверхностную копию]] исходного списка.

```python
>>> squares[:]
[1, 4, 9, 16, 25]
```

Списки также поддерживают конкатенацию:

```python
>>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

В отличие от строк, списки являются мутабельными (изменяемыми) объектами, а их содержимое можно изменять по индексу элемента:

```python
>>> cubes = [1, 8, 27, 65, 125]  # в данной последовательности есть ошибка
>>> 4 ** 3  # куб четырёх должен быть равен 64, а не 65 
64
>>> cubes[3] = 64  # заменим значение для четвёртого элемента списка
>>> cubes
[1, 8, 27, 64, 125]
```

Ещё список допускает добавление новых элементов, через метод `list.append()`:

```python
>>> cubes.append(216)  # добавим куб шести
>>> cubes.append(7 ** 3)  # а также добавим куб семи
>>> cubes
[1, 8, 27, 64, 125, 216, 343]
```

Также списки допускают переопределение срезов, таким образом можно даже изменить размер исходного списка или вовсе очистить его:

```python
>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> # переопределим некоторые значения
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']
>>> # теперь удалим их
>>> letters[2:5] = []
>>> letters
['a', 'b', 'f', 'g']
>>> # очистим список определив его срез от начала до конца пустым списком
>>> letters[:] = []
>>> letters
[]
```

Встроенная функция `len()` также применима и для списков:

```python
>>> letters = ['a', 'b', 'c', 'd']
>>> len(letters)
4
```

Списки в Python также поддерживают вложенность, то есть позволяют в списках хранить другие списки:

```python
>>> a = ['a', 'b', 'c']
>>> n = [1, 2, 3]
>>> x = [a, n]
>>> x
[['a', 'b', 'c'], [1, 2, 3]]
>>> x[0]
['a', 'b', 'c']
>>> x[0][1]
'b'
```

## Программы на Python

Помимо описанных выше операций над числами и текстом, Python позволяет создавать более комплексные программы. Например, рассмотрим последовательность Фибоначчи:

```python
>>> # Последовательность Фибоначчи:
... # каждый последующий элемент равен сумме двух предшествующих ему элементов
... a, b = 0, 1
>>> while a < 10:
...     print(a)
...     a, b = b, a+b
...
0
1
1
2
3
5
8
```

В этом примере используется ранее не описанный синтаксис. Рассмотрим его подробнее.

### Множественное присваивание

В первой строке мы присваиваем значение кортежа `(0, 1)` сразу паре переменных. В данном случае мы как бы распаковываем кортеж и поочередно присваиваем значение элементов внутри соответствующим переменным `a` и `b`.

Если количество элементов в кортеже справа и количество переменных слева будут отличаться, это вызовет ошибку:

```python
>>> a, b, *c = 1, 2, 3, 4
print(a, b, c)
```

### Цикл while

Подсчёт элементов последовательности Фибоначчи происходит в цикле. В данном случае мы используем цикл `while` — цикл с условием. Код в теле такого цикла будет выполняться до тех пор, пока условие цикла остаётся истинным, в данном случае, до тех пор, пока `a < 10`.

В Python в качестве условия может выступать не только логическое выражение, но и любая последовательность или даже число. Внутри условий Python каждое переданное значение будет приведено к типу данных `bool`. Согласно логике такого преобразования, истинной (`True`) будет являться любое значение, отличное от нуля, а также любая последовательность ненулевой длины. Ложью (`False`) будет являться любое другое значение.

Тело цикла в Python — это любая, сколько угодно комплексная логика, помещённая после объявления цикла с отступом в четыре пробела. В Python для определения вложенного блока кода используются отступы, в отличие от большинства других языков, использующих фигурные скобки (`{`).

Блоки кода позволяют определить область видимости для созданных в этих блоках переменных и функций. Также они не ограничены по степени вложенности, то есть каждый из блоков может также содержать вложенные блоки.

### Форматируемый вывод

Мы уже знакомы с функцией `print()` — мы использовали её ранее для вывода результата выражений. Эта функция имеет ряд отличий от нативного вывода, то есть без её использование. Функция `print()` иначе обрабатывает списки, числа с плавающей точкой и строки. Например, строки выводятся без кавычек, а между элементами вставляется пробел, всё это позволяет нам формировать более привлекательный вывод:

```python
>>> i = 256 * 256
>>> print('The value of i is', i)
```

Также, дополнительно к перечисляемым аргументам, `print()` принимает аргумент `end`, с помощью которого мы можем, например, заменить перенос строки (`\n`) на запятую, сделав вывод более компактным:

```python
>>> a, b = 0, 1
>>> while a < 1000:
...    print(a, end=',')
...    a, b = b, a + b
...
0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
```

## Сноски

**Строковый литерал** —	это текст, заключённый в кавычки. ^187c76

**Иммутабельные (неизменяемые) объекты** — это объекты с фиксированным значением. В Python это числа, строки и кортежи. Их значения невозможно изменить. Такие объекты незаменимы там, где требуется постоянное значение хеш-функции, например, в ключах словарей. ^bd5d7c

**Последовательности** — это итерируемые объекты, которые поддерживают эффективный доступ к элементам с использованием целочисленных индексов с помощью специального метода `__getitem__()` и определяют метод `__len__()`, который возвращает длину последовательности. ^cea259

**Поверхностная (shallow) копия** — это копия последовательности, в которой ссылки на изменяемые типы данных не заменяются копиями. Иначе говоря, если в исходном списке хранится мутабельный объект, его поверхностная копия также будет содержать ссылку на этот объект. А это означает, что любые изменения такого объекта в исходном списке приведут к изменениям того же объекта в копии, и наоборот.  ^e83003

## Список источников

- [An Informal Introduction to Python](https://docs.python.org/3/tutorial/introduction.html)