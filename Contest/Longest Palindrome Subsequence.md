---
tags:
 - contest
 - dp
---

![[longest_palindrome_subsequence.png]]
Дана строка `s`, необходимо определить длину самой длинной вложенной последовательности, которая является палиндромом.

> Вложенная последовательность — это последовательность, что может быть образована из исходной последовательности путём удаления некоторых элементов исходной последовательности без изменения порядка оставшихся элементов. 

> Палиндром — это строка, где прядок букв справа на лево и с лева на право одинаковый.

```Python
"bbbab" # самый длинный палиндром bbab длинной 4 буквы
"aabaa" # самый длинный палиндром aabaa длинной 5 букв
"abab"  # самый длинный палиндром bab длинной 3 буквы
"abbab" # самый длинный палиндром bbab длинной 4 буквы
```

## Решение

По сути решение данной задачи сводится к определению такой подстроки, удовлетворяющей условию `[x[1] == y[1], x[n - 1] == y[n - 1], x[n] == y[n]]`, где `x` — это последовательность букв строки  `s` в прямом порядке, а `y` — это последовательность букв строки `s` в обратном порядке.

Хитрость заключается в возможности удалить из результата буквы нарушающие условие `[x[1] == y[1], x[n - 1] == y[n - 1], x[n] == y[n]]`.

Таким образом последовательно сравнив каждую букву из `y` с каждой буквой из `x` мы можем определить палиндром максимальной длинны для для их комбинаций с учётом ранее обнаруженных палиндромов согласно условию:

- Если `x[i] == y[j]`, то мы дополняем ранее обнаруженный палиндром соответствующей буквой: 
	- `memo[i][j] = memo[i - 1][j - 1] + 1`.
- Если `x[i] != y[j]`, то мы выбираем наиболее длинный палиндром либо для буквы `x[i - 1]` либо буквы `y[j - 1]`:
	- `memo[i][j] = max(memo[i - 1][j], memo[i][j - 1])`

![[palindrome_subsequence_dp.png]]

## Пример решения

```Python
def longestPalindromeSubseq(self, s: str) -> int:
    n = len(s)
    prev = [0] * n
    for i in range(n):
        current = [0] * n
        for j in range(n):
            if s[j] == s[n - i - 1]:
                current[j] = prev[j - 1] + 1 if j > 0 else 1
            else:
                count = current[j - 1] if j > 0 else 0
                current[j] = count if count > prev[j] else prev[j]
        prev = current
    return prev[-1]
```