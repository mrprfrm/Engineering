---
author:
  - Anton Petrov
status: Draft
tags:
  - binarysearch
---
Даны целое число `target` и список `nums`. Над списком `nums` могла быть проведена операция поворота со случайным индексом `k`, после которой элементы список принял вид:

$$
[a_{k}, a_{k + 1} , ... , a_{n}, a_{0}, a_{1}, ... , a_{n - 1} ]
$$

Необходимо вернуть индекс `target` если он был найден в списке `nums`, в случае если элемент отсутствует в списке, следует вернуть `-1`.

## Решение

Исходя из условия задачи (задача на поиск), наиболее оптимальным решением можно предположить реализацию двоичного поиска.

Сперва определимся с поворотом исходного списка. Сортировка в данном случае не имеет смысла, поскольку нам необходимо вернуть индекс элемента в списке, где уже произошёл поворот.

Поскольку мы не знаем где именно произошёл поворот и произошёл ли он вообще, мы не можем использовать классическую реализацию двоичного поиска, отсекая одну из частей списка — больше или меньше искомого числа. 

Вместо этого нам следует полагать, что в обеих частях могут находиться как значения больше так и меньше искомого. Для этого мы реализуем рекурсивную функцию поиска и будем передавать туда каждую из частей списка.

```Python
def search(nums: List[int], target: int) -> int:
	def dfs(start, end):
		mid = min(end - 1, end // 2 + start)

		print(start, end, mid)

		if start > end - 1:
			return -1

		if nums[mid] == target:
			return mid
		
		left = dfs(start, mid)
		right = dfs(mid + 1, end)

		return max(left, right)
	
	return dfs(0, len(nums))
```
##  Список источников

- [33. Search in Rotated Sorted Array (leetcode.com)](https://leetcode.com/problems/search-in-rotated-sorted-array/)