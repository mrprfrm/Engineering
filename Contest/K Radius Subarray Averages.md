![[radius_subarray_averages.png]]

Дан список элементов размера `n`, а также радиус `k` — количество элементов слева и справа от текущего. Необходимо найти среднее значение для каждого элемента в диапазоне от `i - k` до `i + k`, то есть в заданном радиусе.
В случае если количество элементов в заданном радиусе меньше `k * 2 + 1`, то среднее значение для текущего элемента следует задать равным `-1`,

## Решение

Для того чтобы найти среднее элементов в заданном диапазоне нам достаточно сложить все имеющиеся элементы в этом диапазоне и затем найти частное от их суммы и их количества.

Для эффективного обхода исходного цикла мы воспользуемся паттерном **Sliding Window** — определим диапазон элементов от `start = i - k` до `end = i + k + 1`, и будем обходить исходный массив в диапазоне, где `start >= k` и `end <= n - k`. Таким образом на каждой итерации мы можем гарантировать, что в заданном "окне" будет фигурировать количество элементов, соответствующее радиусу `k`.

Также определим массив длинны `n` для хранения результата и заполним его `-1`. Таким образом мы будем переопределять только те значения, что попадают в заданный радиус, все остальные элементы мы оставим равными `-1`. 

## Пример решения

```Python
def get_averages(nums: List[int], k: int) -> List[int]:
	n = len(nums)
	result = [-1] * n
	for i in range(k, n - k):
		result[i] = sum(nums[i - k:i + k + 1]) // (k * 2 + 1)
	return result
```

## Оптимизация

Пересчитывать сумму всех элементов в заданном диапазоне — это достаточно дорогая операция, поэтому вместо извлечения среза и последующего нахождения суммы его элементов мы на каждой итерации будет пересчитывать сумму добавляя новый элемент из следующего среза и вычитая первый элемент предыдущего среза, таким образом мы избавимся от необходимости формирования нового среза для каждой итерации цикла.

Сперва определим сумму первых элементов в диапазоне от `0` до `k * 2`, эта сумма не включает в себя крайний правый элемент в заданном радиусе. Это сделано намерено, крайний правый элемент будет добавлять к найденной сумме внутри цикла.

После того как мы нашли среднее значение для заданного диапазона, включая крайний правый элемент, нам необходимо вычесть крайний левый элемент в диапазоне для следующей итерации.

```Python
def get_averages(nums: List[int], k: int) -> List[int]:
	n = len(nums)
	result = [-1] * n
	sm = sum(nums[:k*2])
	for i in range(k * 2, n):
		sm += nums[i]
		result[i - k] = (sm) // (k * 2 + 1)
		sm -= nums[i - k * 2]
	return result
```

## Список источников

- [2090. K Radius Subarray Averages](https://leetcode.com/problems/k-radius-subarray-averages/description/)