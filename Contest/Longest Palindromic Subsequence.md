---
tags:
 - contest
 - dp
 - palindrome
---

![[longest_palindromic_subsequence.png]]

Дана строка `s`, необходимо определить длину самой длинной вложенной последовательности, которая является палиндромом.

> Вложенная последовательность — это последовательность, что может быть образована из исходной последовательности путём удаления некоторых элементов исходной последовательности без изменения порядка оставшихся элементов. 

> Палиндром — это строка, где порядок букв справа на лево и с лева на право одинаковый.

```Python
"bbbab" # самый длинный палиндром bbbb длинной 4 буквы
"aabaa" # самый длинный палиндром aabaa длинной 5 букв
"abab"  # самый длинный палиндром bab длинной 3 буквы
"abbab" # самый длинный палиндром abba длинной 4 буквы
```

## Решение

По сути решение данной задачи сводится к определению непрерывной вложенной последовательности, удовлетворяющей условию:

$x_{1}$ = $y_{1}$, ... , $x_{n-1}$ = $y_{n-1}$, $x_{n}$ = $y_{n}$

где `x` — это последовательность букв строки `s` в прямом порядке, а `y` — это последовательность букв строки `s` в обратном порядке.

В процессе поиска такой вложенной последовательности мы мы будем расчитывать длину таких комбинаций букв, что являются палиндромом и исключать те элементы, что не входят в палиндром.

Таким образом, последовательно сравнив каждую букву из `y` с каждой буквой из `x` мы можем определить палиндром максимальной длинны для всех их комбинаций с учётом ранее обнаруженных палиндромов согласно условию:

- Для всех $x_{i}$ = $y_{i}$ дополняем ранее обнаруженную общую последовательность текущей буквой;
- Для всех $x_{i}$ != $y_{i}$ выбираем наиболее длинную ранее обнаруженную последовательность для $x_{i}$ или $y_{i}$.

![[palindromic_subsequence_dp.png]]

## Пример решения

```Python
def longest_palindrome_subseq(self, s: str) -> int:
    n = len(s)
    prev = [0] * n
    for i in range(n):
        current = [0] * n
        for j in range(n):
            if s[j] == s[n - i - 1]:
                current[j] = prev[j - 1] + 1 if j > 0 else 1
            else:
                count = current[j - 1] if j > 0 else 0
                current[j] = count if count > prev[j] else prev[j]
        prev = current
    return prev[-1]
```