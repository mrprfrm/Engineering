Дано целочисленное значение `x`, а также связанный цикл реализованный через объект вида:

```Python
class ListNode:
	def __init__(self, val = 0, next = None):
		self.val = val
		self.next = next
```

Необходимо все элементы связанного списка меньше `x` поместить в их изначальном порядке слева от значений больше либо равных `x` в их изначальном порядке.

```Python
x, list = 3, [1,4,3,2,5,2] # Результат разделения списка [1,2,2,4,3,5]
x, list = 2, [2,1]         # Результат разделения списка [1,2]
x, list = 4, [2,4,4,9,12]  # Результат разделения списка [2,4,4,9,12]
x, list = 7, [1,1,1,1,1,1] # Результат разделения списка [1,1,1,1,1,1]
```

## Решение

Определим два новых связанных списка, для хранения значений меньше `x` и остальных значений соответственно, а также переменные, где будем хранить начало каждого из списков.

В процессе решения мы реализуем [[Обход связанного списка|обход связанного списка]] и если:

- Текущее значение меньше `x` — добавляем его в левый связанный список и переопределяем текущий элемент первого списка.
- Текущее значение больше либо равно `x` — добавляем его в правый связанный список и переопределяем текущий элемент второго списка.

Переходим к следующему элементу исходного связанного списка и и переопределяем текущий элемент исходного списка.

> Описание данного решение полностью опирается на реализацию [[Обход связанного списка|обхода связанного списка]], поэтому переопределение текущего элемента списка необходимо выполнять вручную.

После того как обход завершён, мы добавляем к концу левого списка начало правого и возвращаем второй элемент левого списка в качестве результата.

> Следует заметить, что мы также будем вынуждены "скипнуть" первые элементы левого и правого списков, поскольку в самом начале мы определили их "пустышками".  

## Пример решения

```Python
def partition(self, head, x):
	l_cur, r_cur = ListNode(), ListNode()
	l_head, r_head = l_cur, r_cur
	
	while head:
		if head.val < x:
			l_cur.next = head
			l_cur = l_cur.next
		else:
			r_cur.next = head
			r_cur = r_cur.next
		head = head.next
	
	l_cur.next = r_head.next
	r_cur.next = None
	return l_head.next
```

## Оптимизация

В контексте данного решения, определение левого и правого списков также может иметь вид:

```Python
def partition(self, head, x):
	l_head = l_cur = ListNode(0)
	r_head = r_cur = ListNode(0)
	...
```

Однако в данном случае мы можем сэкономить несколько миллисекунд на парсинг переменных определив их в одной строчке и затем уже определить дополнительные указатели на готовые значения в памяти.

```Python
def partition(self, head, x):
	l_cur, r_cur = ListNode(), ListNode()
	l_head, r_head = l_cur, r_cur
	...
```

## Список источников

- [Partition List](https://leetcode.com/problems/partition-list/)