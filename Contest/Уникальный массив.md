---
tags:
 - contest
 - stack
---

Дан неотсортированный массив длинны `n`, содержащий неуникальные значения. Обходя массив можно увеличивать текущий элемент на 1 до тех пор пока число в массиве не станет уникальным. Требуется определить количество таких увеличений на протяжении всего массива.

```Python
[1, 2, 2]                # на весь массив приходится 1 увеличение
[3, 2, 1, 2, 1, 7]       # на весь массив приходится 6 увеличений
[1, 4, 6, 8, 2 ,4, 3, 1] # на весь массив приходится 7 увеличений
[4, 1, 3, 1, 6, 1]       # на весь массив приходится 5 увеличений
```

## Решение

Исходя из условия задачи, мы можем создать массив (`результат`), куда будем помещать только уникальные значения в процессе обхода исходного массива, таким образом для каждого текущего элемента мы будем проверять является ли он дубликатом, то есть поместили ли мы ранее элемент с таким же значением в `результат`.

Если `результат` содержит элемент с текущим значением, то последовательно в цикле увеличиваем это значение и ответ нашего решения (`счётчик`) на единицу.

В противном случае просто помещаем текущее значение в  `результат`.

В конце возвращаем значение `счётчика`.

> Сразу следует заметить, что подобный подход не является оптимальным, поскольку нам понадобится использовать дополнительный вложенный цикл, поэтому от такой реализации мы отказываемся.

## Пример решения

```Python
def count_increments(nums):
	count = 0
    result = []
    for el in nums:
        while el in result:
            count += 1
            el += 1
        result.append(el)
    return count
```

## Оптимизация

В описанной ранее реализации мы вынуждены использовать вложенный цикл, поскольку мы не знаем конкретный индекс элемента с текущим значением в `результате`. Чтобы избавиться от лишнего цикла мы можем находить разницу между текущим элементом и ближайшим предыдущим элементом, что мы уже поместили в результат, однако для этого нам необходимо знать индекс этого элемента в результате. 

Чтобы решить эту проблему мы упорядочим элементы в исходном массиве, таким образом ближайший предыдущий элемент в `результате` будет находиться слева от текущего.

Также в условии задачи ничего не сказано об иммутабельности исходного массива, что позволит нам использовать его в качестве `результата` и сэкономить на операциях добавления нового элемента в массив, поскольку мы сможем просто менять значение внутри исходного массива.

> Данный подход является менее безопасным, однако более экономным, поскольку у нас уже имеется массив определённой длинны и у нас нет необходимости выделять дополнительную память для хранения `результата`. а также операция переопределения значения по индексу, является более оптимальной, чем добавление нового элемента в массив.

Последовательно обходя отсортированный исходный массив, начиная со второго элемента, мы будем сравнивать текущий элемент с предыдущим, и в случае, если он меньше либо равен предыдущему, то мы можем сразу определить текущий элемент на единицу больше предыдущего, а также посчитать разницу между текущим и предыдущим значением и прибавить её к `счётчику`.

```Python
def count_increments(nums):
	count = 0
    data = sorted(nums)
    for i in range(1, len(data)):
        if data[i] <= data[i - 1]:
            count += data[i - 1] - data[i] + 1
            data[i] = data[i - 1] + 1
    return count
```

## Выводы

Когда решение не предполагает использования массива исходных данных во внешних функциях, можно очень сильно сэкономить по времени и по памяти, банально изменяя исходные данные по индексу. В этом случае мы не выделяем дополнительной памяти для сохранения результата, а так же не выделяем память динамически на добавление новых элементов к результату.
