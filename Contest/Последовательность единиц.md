---
tags:
 - contest
 - stack
---

Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.

**Примеры**

```Python
"1110011010001110111101101" # 4 единицы подряд
"0011010001110111011011111" # 5 единиц подряд
"00000000000000000000"      # 0 единиц подряд
"111111111101111111111"     # 5 единиц подряд
```

## Решение

Исходя из условия задачи, нам необходимо посчитать продолжительность каждой последовательности единиц во входной последовательности и затем определить из них последовательность максимальной длинны. Каждый раз встречая ноль, текущий счётчик непрерывной последовательности  следуем поместить в [[Стеки, очереди, деки#^8b5d53|стек]] и затем обнулить его.

 Следует заметить, у данного решении, несмотря на его приемлемую оптимальность, имеется несколько узких мест: 

1. Совершенно необязательно хранить длинны всех непрерывных последовательностей, достаточно хранить лишь максимальную и переопределять её когда мы сталкиваемся с большей;
2. Определение последовательности максимальной длинны ПОСЛЕ подсчёта длин всех непрерывных последовательностей потребует по крайней мере ещё одного обхода по массиву с этими длинами, чего можно избежать в случае определения максимальной длинны в процессе их подсчёта.  

## Пример решения

```Python
def queue(a):
    count = 0
    counts = []
    for i in a:
        if i == 1:
            count += 1
        else:
            counts.append(count)
            count = 0
    counts.append(count)

    return max(counts)
```

## Оптимизация

Следует заметить, у данного решении, несмотря на его приемлемую оптимальность, имеется несколько узких мест: 

1. Совершенно необязательно хранить длинны всех непрерывных последовательностей, достаточно хранить лишь максимальную и переопределять её когда мы сталкиваемся с большей;
2. Определение последовательности максимальной длинны ПОСЛЕ подсчёта длин всех непрерывных последовательностей потребует по крайней мере ещё одного обхода по массиву с этими длинами, чего можно избежать в случае определения максимальной длинны в процессе их подсчёта.  

```Python
def queue(a):
    count = 0
    max_count = 0
    for el in a:
        if el < 1:
            max_count = max(count, max_count)
            count = 0
        else:
            count += 1

    max_count = max(count, max_count)

    return max_count
```

Также следует заметить, что в `Python` для определения максимума из двух элементов наиболее подходящим является использование `тернарного оператора` вместо функции `max`.

Функция `max` не смотря, что она выполняется на языке `c` и является более быстрой альтернативой определения максимума в списке по сравнению с собственной реализацией на `Python`, всё же является функцией, в то время как `тернарный оператор` является операцией.

```Python
def queue(a):
    count = 0
    max_count = 0
    for el in a:
        if el < 1:
            max_count = count if count > max_count else max_count
            count = 0
        else:
            count += 1

    max_count = count if count > max_count else max_count

    return max_count
```

## Выводы

При определении наиболее оптимального решения учитывались две метрики: **средняя скорость выполнения** и **количество вызовов** внутри функции. Результаты выполнения приведены ниже.

Исходя их результатов профиилирования, приведённых ниже, можно сделать вывод, что наиболее оптимальным является решение определения максимума длин последовательностей "на лету", однако многократное использование функции `max` сводит преимущества такого подхода на нет и выполняется дольше чем наивный подход к решению задачи, в то время как использование тернарного оператора показывает наилучший результат.

Также следует заметить, что использование функции `max` ПОСЛЕ определения длин непрерывных последовательностей, показывает вполне приемлемый результат, из чего можно сделать вывод, что множественные вызовы, даже очень оптимальных функций, сильно уступают в производительности по сравнению с операциями, но являются допустимым решением для использования на более длинных коллекциях с минимальным количеством вызовов.

| Решение                        | Средняя скорость выполнения | Количество вызовов |
| ------------------------------ | --------------------------- | ------------------ |
| Решение со стеком              | 3.36 * 10 ^ -6 секунд       | 5                  |
| Решение с функцией `max`       | 3.82 * 10 ^ -6 секунд       | 14                 |
| Решение с тернарным оператором | 1.82 * 10 ^ -6 секунд       | 4                  |
