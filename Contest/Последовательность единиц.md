---
tags:
 - contest
 - yandex
---

> Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.

## Алгоритм

1. Объявить пустой `список счётчиков`
2. Объявить переменную для хранения значения `счётчика`
3. Обойти `исходный вектор`
	1. Если `текущий элемент` — это единица, то увеличиваем значение `счётчика`
	2. Если `текущий элемент` — не единица:
		1. Записываем значение в `список счётчиков` 
		2. Обнуляем `счётчик`
4. Добавляем крайнее значение `счётчика` в `список`
5. Находим максимальное значение `счётчика` в `списке`
6. Возвращаем результат

## Решение

```Python
def queue(a):
    count = 0
    counts = []
    for i in a:
        if i == 1:
            count += 1
        else:
            counts.append(count)
            count = 0
    counts.append(count)

    return max(counts)
```

### Профилирование

| Параметр | Значение |
| --- | --- |
| Среднее время  выполнения | 3.36 * 10 ^ -6 секунд |
| Количество вызовов внутри функции | 5 |

 Следует заметить, что данный алгоритм не является оптимальным, поскольку после создания коллекции со счётчиками нам нужно будет пройтись по этой коллекции, что безусловно (даже при условии, что мы используем оптимальные функции определения максимума коллекции) займёт, и больше времени, и памяти для хранения счётчиков.

 Более оптимальным выглядит алгоритм определения максимального значения счётчика  «на лету», то есть в процессе обхода исходного вектора. 

## Оптимальный алгоритм

1. Объявить переменную для хранения `максимального значение счётчика`, равную нулю
2. Обойти `исходный вектор`
	1. Если `текущий элемент` — это единица, то увеличиваем значение `счётчика`
	2. Если `текущий элемент` — не единица:
		1. Если текущее `значение счётчика` больше `максимального`, то переопределяем `максимальное значение счётчика`
		2. Обнуляем `счётчик`
3. Если `текущее значение` счётчика больше `максимального`, то переопределяем `максимальное значение счётчика`
4. Возвращаем результат

## Решение

```Python
def queue(a):
    count = 0
    max_count = 0
    for el in a:
        if el < 1:
            max_count = count if count > max_count else max_count
            count = 0
        else:
            count += 1

    max_count = count if count > max_count else max_count

    return max_count
```

### Профилирование

| Параметр | Значение |
| --- | --- |
| Среднее время  выполнения | 1.82 * 10 ^ -6 секунд |
| Количество вызовов внутри функции | 4 |

 Можно также попробовать заменить тернарный оператор на функцию `max`, однако в этом случае скорость работы алгоритма будет несколько ниже, а количество вызовов внутри функции в несколько раз больше 

## Более читаемое решение 

```Python
def queue(a):
    count = 0
    max_count = 0
    for el in a:
        if el < 1:
            max_count = max(count, max_count)
            count = 0
        else:
            count += 1

    max_count = max(count, max_count)

    return max_count
```

### Профилирование

| Параметр | Значение |
| --- | --- |
| Среднее время  выполнения | 3.82 * 10 ^ -6 секунд |
| Количество вызовов внутри функции | 14 |