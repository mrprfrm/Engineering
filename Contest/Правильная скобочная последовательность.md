---
tags:
 - contest
 - stack
 - recursion
---

Следует определить является ли входная скобочная последовательность `a` правильной.

> Под правильной скобочной последовательностью понимается, последовательность скобок, где каждой открывающей скобке соответствует только одна закрывающая.

**Примеры**

```Python
"((())(())())" # Правильная скобочная последовательность
"(()))"        # Неправильная скобочная последовательность
"(((([])){}))" # Правильная скобочная последовательность
"(((([))))]"   # Неправильная скобочная последовательность
```

## Решение

Если перевести задачу в плоскость практического решения, то выходит, что нам необходимо определить является ли последовательность скобок сбалансированной , иначе говоря является ли количество открывающих скобок равным закрывающим.

Каждый раз встречая открывающую скобку мы будем помещать её в [[Стеки, очереди, деки#^8b5d53|стек]] , а встречая соответствующую ей закрывающую скобку мы будем удалять её из стека. 

> Исходя из вышеописанного может возникнуть соблазн решить задачу используя счётчик вместо стека, однако следует заметить что в последовательности нам могут встречаться разные типы скобок (круглые, квадратные или фигурные) и как следствие при подсчёте баланса скобок должен быть учтён порядок их вложенности.

### Критерий сбалансированности

Если в процессе перебора нам попадётся закрывающая скобка без соответствующей открывающей внутри стека, можно считать последовательность **несбалансированной**.

Если по завершении перебора исходной последовательности стек окажется пустым, можно считать последовательность **сбалансированной**, иначе **несбалансированной**.

## Пример решения

```Python
def validateBracketsSequence(sequence):
	saved = []
	pairs = {")": "(", "]": "[", "}": "{"}
	for bracket in sequence:
		if bracket in "([{":
			saved.append(bracket)
		else:
			pair = pairs.get(bracket)
			if len(saved) > 0 and saved[-1] == pair:
				saved.pop()
			else:
				return False
	return len(saved) < 1
```