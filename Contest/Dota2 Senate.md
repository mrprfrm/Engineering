---
tags:
 - contest
 - medium
 - stack
---

В мире Dota2 есть две стороны: `Radiant` и `Dire`.

Сенат Dota2 состоит из сенаторов от двух партий. Сенат хочет принять решение об изменении игры в Dota2. Голосование — это процедура, проходящая в несколько раундов. В каждом раунде каждый сенатор может воспользоваться одним из двух прав:

- Забанить одного из сенаторов: сенатор может лишить другого сенатора всех его прав в этом и всех последующих раундах;
- Объявить победу: если этот сенатор обнаружил, что все сенаторы, что ещё имеют право голоса, принадлежат к одной партии, он может объявить победу и принять решение об изменении в игре.

Дана строка, представляющая партийную принадлежность каждого сенатора. Персонажи `R` и `D` представляют стороны `Radiant` и `Dire`. В случае если сенат состоит из `n` сенаторов, строка будет иметь соответствующую длину в `n` символов.

Голосование начинается с первого сенатора до последнего в заданном порядке. Все сенаторы, потерявшие свои права, во время голосования будут пропущены.

Предположим, что каждый сенатор достаточно умен и будет использовать наилучшую стратегию для своей партии. Угадайте, какая сторона объявит о победе и изменит игру в Dota 2. Вывод должен быть `Radiant` или `Dire`.

```Python
"RD"     # Победит партия "Radiant"
"D"      # Победит партия "Dire"
"DDRRR"  # Победит партия "Dire"
"DDRRRR" # Победит партия "Radiant"
```

## Решение

Решение данной задачи сводится к созданию зацепленной очереди. Каждый раз сенатор используя своё право будет перемещаться в конец очереди для повторного голосования в следующем раунде, при условии что он не был забанен ранее. В случае если сенатор был забанен его черёд просто переходит к следующему в очереди.

Каждый раз голосуя сенатор как бы выходит из очереди и если он был забанен, то он просто покидает список сенаторов окончательно, иначе он использует право бана и возвращается в конец очереди.

Поскольку все сенаторы представлены исключительно названием собственной партии, каждому сенатору совершенно не важно в каком порядке банить оставшихся представителей противоборствующей партии и мы смело можем исключать оных из списка сенаторов просто по порядку.

В конце голосования в списке сенаторов останутся только представители одной партии, и название этой партии и будет являться ответом.

## Пример решения

```python
from collections import deque

def predict_party_victory(senate: str) -> str:
	senate, senator = deque(senate), None

	if "R" not in senate or "D" not in senate:
		senator = senate[0]

	while senate and "R" in senate and "D" in senate:
		senator = senate.popleft()
		oposit = "R" if senator == "D" else "D"
		senate.remove(oposit)
		senate.append(senator)
	
	return "Radiant" if senator == "R" else "Dire"
```

## Оптимизация

В процессе удаления элемента из списка на уровне python мы последовательно перебираем все элементы очереди, до тех пор пока не наткнёмся на искомое значение, что занимает дополнительное время и явно зависит от позиции искомого элемента в очереди и общего количества элементов очереди.

Вместо явного удаления элемента через метод `remove` мы можем просто пропустить его очередь в случае если за его бан уже проголосовали ранее. 

Количество банов мы можем хранить в отдельном счётчике и увеличивать его если участник соответствующей партии банит одного из своих оппонентов и уменьшать его если сенатор противоборствующей партии покинул очередь.

> Для удобства к счетчику банов мы можем получать доступ по ключу, поместив значение счётчика в словарь, это позволит на описать общий случай расчёта банов для обеих партий. 

```python
from collections import deque

def get_name(code):
	return "Radiant" if code == "R" else "Dire"
        
def predict_party_victory(senate: str) -> str:
	if "R" not in senate or "D" not in senate:
		return get_name(senate[0])
		
	senate, last_senator = deque(senate), None
	skip_map = {"R": 0, "D": 0}
	while senate and "R" in senate and "D" in senate:
		senator = senate.popleft()
		if skip_map[senator] > 0:
			skip_map[senator] -= 1
		else:
			oposit = "R" if senator == "D" else "D"
			skip_map[oposit] += 1
			senate.append(senator)
			
	return get_name(senate[0])
```

Следует заметить, что в процессе решения мы обновляем только первый и последний элемент очереди и подобная операция вполне осуществима и с использованием строк.

Вместо метода `popleft` мы создадим срез строки от второго элемента до конца, что позволит нам отказаться от преобразования исходной строки в очередь и как следствие сильно понизить затраты на выполнение функции по времени.

```python
def get_name(code):
	return "Radiant" if code == "R" else "Dire"
	
def predict_party_victory(senate: str) -> str:
	if "R" not in senate or "D" not in senate:
		return get_name(senate[0])
		
	skip_map = {"R": 0, "D": 0}
	while senate and "R" in senate and "D" in senate:
		senator, senate = senate[0], senate[1:]
		if skip_map[senator] > 0:
			skip_map[senator] -= 1
		else:
			oposit = "R" if senator == "D" else "D"
			skip_map[oposit] += 1
			senate += senator
			
	return get_name(senate[0])
```

## Список источников

- [649. Dota2 Senate](https://leetcode.com/problems/dota2-senate/)